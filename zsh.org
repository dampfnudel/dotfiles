#+AUTHOR: Markus Bayer
#+DATE: [2017-11-17 Fr]
#+BABEL: cache no
#+PROPERTY: header-args shell :tangle zsh.zsh

#          ‚ñÑ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÑ     ‚ñÑ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà    ‚ñÑ‚ñà    ‚ñà‚ñÑ       ‚ñÑ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñÑ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
#          ‚ñÄ‚ñà‚ñÄ‚ñÑ‚ñà‚ñà‚ñà‚ñÄ‚ñÑ‚ñÑ   ‚ñà‚ñà‚ñà         ‚ñÑ‚ñà‚ñà‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñà‚ñà‚ñà‚ñÑ‚ñÑ  ‚ñÑ‚ñà‚ñà‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñà‚ñà‚ñÄ ‚ñà‚ñà‚ñà
#           ‚ñÑ‚ñà‚ñà‚ñà‚ñÄ   ‚ñÄ ‚ñÄ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñÄ‚ñÄ‚ñà‚ñà‚ñà‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñà‚ñà‚ñà‚ñÄ  ‚ñÄ‚ñÄ‚ñà‚ñà‚ñà‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ   ‚ñà‚ñà‚ñà
#         ‚ñÑ‚ñà‚ñà‚ñà‚ñÄ                ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà   ‚ñÄ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà    ‚ñà‚ñÑ
# ‚ñà‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà‚ñÑ     ‚ñÑ‚ñà    ‚ñÑ‚ñà    ‚ñà‚ñà‚ñà   ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà     ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà
# ‚ñà‚ñà‚ñà‚ñà     ‚ñÄ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÄ  ‚ñÑ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÄ    ‚ñà‚ñà‚ñà    ‚ñà‚ñÄ      ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
#                                                   ‚ñà‚ñà‚ñà    ‚ñà‚ñà‚ñà

# ASCII-Art credits: http://patorjk.com/software/taag/#p=display&f=Delta%20Corps%20Priest%201&t=.zshrc
* INDEX
[[#INDEX]]
[[#setup]]
[[#environment]]
[[#completions]]
[[#aliases]]
[[#functions]]
[[#keybindings]]
[[#plugins]]
[[#original-zshrc]]

* Setup
:PROPERTIES:
:CUSTOM_ID: setup
:END:
** org-tangle
#+BEGIN_SRC shell
tangle () {
    FILE=$(realpath $1)
    open -a /usr/local/Cellar/emacs/25.2/Emacs.app --args --eval "(progn
        (require 'org)
        (find-file (expand-file-name \"$FILE\"))
        (org-babel-tangle))"
}
#+END_SRC

** symlink
#+BEGIN_SRC shell
old () {
    rm ~/.zshrc
    ln -s ~dotfiles/zshrc.zsh ~/.zshrc
}

new () {
    rm ~/.zshrc
    ln -s ~dotfiles/zsh.zsh ~/.zshrc
}
#+END_SRC

* Environment
:PROPERTIES:
:CUSTOM_ID: environment
:END:

** iterm2 shell integration                                         :plugin:
#+BEGIN_SRC shell
  # https://www.iterm2.com/documentation-shell-integration.html
  # source ~dotfiles/zsh/iterm2_shell_integration/iterm2_shell_integration.zsh
#+END_SRC

** ZSH Options
http://zsh.sourceforge.net/Doc/Release/Options.html

unsetopt option == setopt no_option
#+BEGIN_SRC shell
# allow to change to a directory by entering it as a command
setopt auto_cd
# prevent > redirection from truncating the given file if it already exists
setopt no_clobber
# recognize comments
setopt interactivecomments

## correction
# automatically correct the spelling of each word on the command line
setopt correct_all
# try to correct the spelling of commands.
setopt correct

## history
# zsh sessions will append their history list to the history file, rather than replace it. Thus, multiple parallel zsh sessions will all have the new entries from their history lists added to the history file
setopt append_history
# works like APPEND_HISTORY except that new history lines are added to the $HISTFILE incrementally (as soon as they are entered), rather than waiting until the shell exits
setopt inc_append_history
# save each command‚Äôs beginning timestamp (in seconds since the epoch) and the duration (in seconds) to the history file
setopt extended_history
# the oldest history event that has a duplicate will be lost before losing a unique event from the list
setopt hist_expire_dups_first
# ignore duplication command history list
setopt hist_ignore_dups
# remove command lines from the history list when the first character on the line is a space
setopt hist_ignore_space
# whenever the user enters a line with history expansion, don‚Äôt execute the line directly; instead, perform history expansion and reload the line into the editing buffer.
setopt hist_verify
# use the same history file for all sessions
setopt share_history

## completion
# do not autoselect the first completion entry
unsetopt menu_complete
# show completion menu on successive tab press
setopt auto_menu
# if unset, the cursor is set to the end of the word if completion is started. Otherwise it stays there and completion is done from both ends.
setopt complete_in_word
# if a completion is performed with the cursor within a word, and a full completion is inserted, the cursor is moved to the end of the word. That is, the cursor is moved to the end of the word if either a single match is inserted or menu completion is performed.
setopt always_to_end
#+END_SRC

** Hashes
#+BEGIN_SRC shell
export HOME=/Users/mbayer
# projects
hash -d ai=$HOME/Workspace/ai
hash -d amber=$HOME/Workspace/amber
hash -d bay=$HOME/Workspace/bay
hash -d gists=$HOME/Workspace/gists
hash -d hackedHN=$HOME/Workspace/hackedHN
hash -d impure=$HOME/Workspace/impure
# system
hash -d bin=$HOME/bin
hash -d desktop=$HOME/Desktop
hash -d dev=$HOME/Workspace
hash -d documents=$HOME/Documents
hash -d dotfiles=$HOME/Settings/dotfiles
hash -d downloads=$HOME/Downloads
hash -d dropbox=$HOME/Dropbox
hash -d emacs.d=$HOME/.emacs.d
hash -d library=$HOME/Library
hash -d music=$HOME/Music
hash -d oh-my-zsh=$HOME/.oh-my-zsh
hash -d org=$HOME/Documents/org
hash -d pictures=$HOME/Pictures
hash -d screenshots=~pictures/Screenshots
hash -d regiobot=$HOME/Workspace/project-inquant/gitlab
hash -d rezepte=$HOME/Documents/org/rezepte
hash -d scripts=$HOME/Workspace/scripts
hash -d settings=$HOME/Settings
hash -d tmp=$HOME/tmp
hash -d trash=$HOME/.Trash
hash -d utils=$HOME/utils
hash -d videos=$HOME/Movies
# mounts
hash -d i32=/Volumes/INGOT32
hash -d i64=/Volumes/INGOT64
hash -d sd2=/Volumes/sd2
hash -d sd=/Volumes/sd
hash -d v=/Volumes
# mobile
hash -d mobile_audiobooks=root@192.168.178.41:/storage/extSdCard/Audiobooks
hash -d mobile_images=root@192.168.178.41:/storage/extSdCard/DCIM
hash -d mobile_org=root@192.168.178.41:/storage/sdcard0/org_m
hash -d mobile_sd=root@192.168.178.41:/storage/extSDCard
hash -d mobile_storage=root@192.168.178.41:/storage/sdcard0
# files
hash -d emacsrc=$HOME/Settings/dotfiles/emacsrc.org
hash -d vimrc=$HOME/Settings/dotfiles/vimrc.vim
hash -d zsh_history=$HOME/.zsh_history
hash -d zshrc=$HOME/Settings/dotfiles/zshrc.zsh
#+END_SRC

** ZSH Parameters
#+BEGIN_SRC shell
# $PATH
export PATH="/usr/local/bin:/usr/local/sbin:/usr/bin:/bin:/usr/sbin:/sbin:$HOME/bin:$PATH"

# paths
# TODO hash?
export BIN=/usr/local/bin
export DOTFILES="$HOME/Settings/dotfiles"

# language
export LANG=de_DE.UTF-8
export LC_ALL=de_DE.UTF-8

# history
# TODO rm 2
export HISTFILE="$HOME/.zsh_history2"
export HISTSIZE=1200000
export SAVEHIST=1000000

# $EDITOR
if [[ -n $SSH_CONNECTION ]]; then
    export EDITOR="$BIN/vim"
else
    export EDITOR=~scripts/emacs.sh
    # TODO rm obsolete
    export EDITOR_TAB=${EDITOR}
    export VIM_EDITOR="$BIN/mvim"
    # TODO function || alias
    export VIM_EDITOR_TAB="${VIM_EDITOR} --remote-tab-silent"
fi

# A list of non-alphanumeric characters considered part of a word by the line editor.
export WORDCHARS='*?_-.[]~=/&;!#$%^(){}<>/'

# $LS_COLORS
# TODO 
eval $(gdircolors -b "$DOTFILES/monobay.256dark")
# used by k
# export LSCOLORS='di=36:ln=35:so=32:pi=33:ex=31:bd=34;46:cd=34;43:su=30;41:sg=30;46:tw=30;42:ow=30;43'
export LSCOLORS='exfxcxdxbxegedabagacad'

#+END_SRC

** Python Parameters
#+BEGIN_SRC shell
# project amber
export DJANGO_SETTINGS_MODULE=amber.settings
#+END_SRC

** Other Parameters
*** encryption
#+BEGIN_SRC shell
# PGP
GPG_TTY=$(tty)
export GPG_TTY
#+END_SRC

** command variables

* Completions
:PROPERTIES:
:CUSTOM_ID: completions
:END:
http://zsh.sourceforge.net/Doc/Release/Roadmap.html#Completion-1
http://zsh.sourceforge.net/Doc/Release/Options.html#Completion-2
http://www.masterzen.fr/2009/04/19/in-love-with-zsh-part-one/
https://unix.stackexchange.com/questions/185537/combining-zsh-s-tab-completion-with-case-insensitivity
#+BEGIN_SRC shell
# initialize the completion system
autoload -U compinit && compinit
# enable menu widget
# zstyle ':completion*:default' menu 'select=1'
zstyle ':completion:*' menu select
# use dircolors in completion listings
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}
# color options red, descriptions green
zstyle ':completion:*:options' list-colors '=(#b)*(-- *)=31=32'
zstyle ':completion:*:common-commands' list-colors '=(#b)*(-- *)=31=32'
# print the completion type
zstyle ':completion:*' verbose yes
zstyle ':completion:*' format 'Completing %B%d%b'
# TODO style
zstyle ':completion:*:descriptions' format "$fg[yellow]%B--- %d%b"
zstyle ':completion:*:messages' format '%d'
zstyle ':completion:*:warnings' format "$fg[red]No matches for:$reset_color %d"
zstyle ':completion:*:corrections' format '%B%d (errors: %e)%b'
# group different completion types
zstyle ':completion:*' group-name ''
# error can be a transposed character, a missing character or an additional character
# to have a better heuristic, by allowing one error per 6 character typed
zstyle ':completion:*:approximate:*' max-errors 'reply=( $(( ($#PREFIX+$#SUFFIX)/6 )) numeric )'
# case insensitive matching
zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}' 'r:|=*' 'l:|=* r:|=*'
# caching
zstyle ':completion:*' use-cache on
# TODO required?
zstyle ':completion:*' cache-path "$HOME/.zsh/cache"
# ignore completion functions for commands you don‚Äôt have:
zstyle ':completion:*:functions' ignored-patterns '_*'
# don't complete uninteresting users
zstyle ':completion:*:*:*:users' ignored-patterns \
    adm amanda apache at avahi avahi-autoipd beaglidx bin cacti canna \
    clamav daemon dbus distcache dnsmasq dovecot fax ftp games gdm \
    gkrellmd gopher hacluster haldaemon halt hsqldb ident junkbust kdm \
    ldap lp mail mailman mailnull man messagebus  mldonkey mysql nagios \
    named netdump news nfsnobody nobody nscd ntp nut nx obsrun openvpn \
    operator pcap polkitd postfix postgres privoxy pulse pvm quagga radvd \
    rpc rpcuser rpm rtkit scard shutdown squid sshd statd svn sync tftp \
    usbmux uucp vcsa wwwrun xfs '_*'
# don't complete uninteresting files
zstyle ':completion:*:emacs:*' ignored-patterns '*.(o|a|so|aux|dvi|swp|fig|bbl|blg|bst|idx|ind|out|toc|class|pdf|ps|pyc)'
# avoid getting offered the same filename with rm
zstyle ':completion:*:rm:*' ignore-line yes
#+END_SRC

** Python

      path=(
          $path
          /usr/bin/python
          /usr/local/bin/python3
      )

      # virtualenv {
          export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python
          export PROJECT_HOME=$HOME/Workspace
          export WORKON_HOME=$HOME/Workspace/Envs
          export VIRTUALENV_ROOT=$WORKON_HOME
          export DEFAULT_PYTHON_INTERPRETER=$WORKON_HOME/python3.4.1/bin/python
          source /usr/local/bin/virtualenvwrapper.sh

          # fix the new tab = virtual_env dir bug
          if [[ "$PWD" == "$HOME/Workspace/Envs" ]]; then
              cd - > /dev/null
          fi

*** virtualenvwrapper                                              :plugin:
https://virtualenvwrapper.readthedocs.io/en/latest/
#+BEGIN_SRC shell
export WORKON_HOME=~dev/Envs
export PROJECT_HOME=~dev
source "$BIN/virtualenvwrapper.sh"
#+END_SRC

*** virtualenv                                                     :plugin:
https://virtualenv.pypa.io/en/latest/
#+BEGIN_SRC shell
# set default virtual_env
export VIRTUALENV_DEFAULT_PATH="$WORKON_HOME/python3.4.1/bin/activate"
# load it
if [[ $(basename "$VIRTUAL_ENV") == "" ]]
then
    if [[ -f "$VIRTUALENV_DEFAULT_PATH" ]]; then
        source "$VIRTUALENV_DEFAULT_PATH"
    fi
fi
#+END_SRC

* Aliases
:PROPERTIES:
:CUSTOM_ID: aliases
:END:

              clipboard_plain_text () {
                  pbpaste | textutil -convert txt -stdin -stdout -encoding 30 | pbcopy
              }
              print_shrug () {
                  echo "¬Ø\_(„ÉÑ)_/¬Ø"
              }
              print_python_kws () {
                  python -c "import keyword
  for kw in keyword.kwlist:
      print(kw)"
              }
              # >--< <- rm from clipboard entry
              # >>> import hashlib
              rm_prefix (){
                  pbpaste|cut -c 4-|pbcopy
              }
#+BEGIN_SRC shell
# TODO section for overriding
## list
# use gnu ls for dircolors
alias ls='gls --color=auto'
# list details
alias ll='ls -lah'
# sort by size
alias lss='ls -lahS'
# sort by date
alias lsd='ls -latr'
# only today
alias lst='find . -maxdepth 1 -type f -mtime 1'
# numFiles: number of (non-hidden) files in current directory
alias lsc='echo $(ls -1 | wc -l)'
alias k='k -h'     # human readable sizes
# disk usage statistics default
alias du="du -ach | sort"
# free diskspace with human readable size
alias df='df -h'
# stat with human readable times
alias stat='stat -x'

## tools
# emacs
alias e="eval $EDITOR"
# vim
alias cvim='/usr/local/bin/vim'
# create parent directories on demand
alias mkdir="mkdir -pv"
# clipboard
alias p='pbpaste'
alias y='pbcopy'
alias bpython='$WORKON_HOME/python3.4.1/bin/bpython'
## find
# ripgrep as find
# TODO define in var
alias fd="rg --files --no-ignore --hidden --follow -g '!{.git,node_modules}/*'"
# continue the download in case of problems
alias grep='grep --color'
## internet
alias wget="wget -c"
alias chrome='/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome'
alias chrome_headless='/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --headless --disable-gpu'
alias yt3='$WORKON_HOME/python3.4.1/bin/youtube-dl --verbose --extract-audio --audio-format mp3 --no-mtime --no-cache-dir'
alias yt='$WORKON_HOME/python3.4.1/bin/youtube-dl --no-mtime --no-cache-dir'
# weather
alias wttr='curl -s http://wttr.in | tail +8 | head -30'
# moonphase
alias moon='curl -s wttr.in/Moon|head -25'

# git
alias gs='git status'
alias gpl='git pull'
alias gps='git push'
alias gl='git log'
alias gco='git checkout'

alias git_push_fire='git add -A && git commit -a --allow-empty-message -m "" && git push'
alias git_undo_commit='git reset --soft HEAD~'

## actions
alias s='source ~zshrc'
# TODO as functions
# TODO internal/external
alias print_ip='ifconfig | grep "inet " | grep -v 127.0.0.1 | cut -d\  -f2'
# substitute windows linebreak with unix linebreak
alias fix_linebreaks="/usr/bin/perl -i -pe's/\r$//'"
alias pip_update_all="pip freeze --local | grep -v '^\-e' | cut -d = -f 1  | xargs -n1 pip install -U"

alias osx_show_hidden='defaults write com.apple.Finder AppleShowAllFiles YES && killall Finder'
alias osx_hide_hidden='defaults write com.apple.Finder AppleShowAllFiles NO && killall Finder'
alias osx_empty_trash="rm -rf ~/.Trash/."
alias fix_carriage_return="tr '\r' '\n' <"

## cleanup
# TODO as functions
# rm_DS_Store_files: removes all .DS_Store file from the current dir and below
alias rm_ds_store='find . -name .DS_Store -exec rm {} \;'
alias rm_pyc_files='find . -name "*.pyc" -exec rm {} \;'
alias rm_svn_files='find . -type d -name .svn -exec rm -rf {} \;'
alias rm_emacs_files="find . -maxdepth 1 -type f -name '#*#' -exec rm {}\;"
#+END_SRC

** Global aliases
#+BEGIN_SRC shell
## redirection
# redirect stdout, stderr
alias -g _no_output='> /dev/null 2>&1'
# redirect stderr
alias -g _no_stderr='2> /dev/null'
# redirect stdout
alias -g _no_stdout='&> /dev/null'

## tools
alias -g _vim="| eval ${EDITOR_TAB}"
alias -g _y='| pbcopy'

## files
# alias -g PASS='<(ypcat passwd)'
alias -g _brew='<(brew list)'
alias -g _pip='<(pip freeze)'
alias -g _gem='<(gem list | tail -n +1)'
#  ¬Ø\_(„ÉÑ)_/¬Ø
alias -g _npm="<(npm list -g --depth=0 2> /dev/null |cut -c5- | tail -n +2 | sed \$d)"
# TODO function wrapper
alias -g _shrugf='<(echo "¬Ø\\_(„ÉÑ)_/¬Ø")'

## variables
alias -g _shrugv='${$(echo "¬Ø\\_(„ÉÑ)_/¬Ø")}'

## filter
# filter columns
alias -g _awk1="|awk '{print \$1}'"
alias -g _awk2="|awk '{print \$2}'"
alias -g _awk3="|awk '{print \$3}'"
alias -g _awk4="|awk '{print \$4}'"
alias -g _awk5="|awk '{print \$5}'"
alias -g _awk6="|awk '{print \$6}'"
# filter with fzf
alias -g _f="|fzf"
# pager
alias -g _l="|less"
# count lines
alias -g _cl='|wc -l'
alias -g _lc='_cl'
# archives in pwd
alias -g _acd='./(*.bz2|*.gz|*.tgz|*.zip|*.z)'
## map
# funky
alias -g _x='| xargs'
alias -g map='_x'
#+END_SRC

** Suffix aliases
#+BEGIN_SRC shell
# TODO
# open org-mode files in emacs
alias -s org=emacs
# TODO Glob
alias -s jpg=imgcat
alias -s png=imgcat
#+END_SRC

* Functions
:PROPERTIES:
:CUSTOM_ID: functions
:END:
# TODO echo $nameddirs|tr " " "\n"|fzf

** Helper functions
#+BEGIN_SRC shell
function __expect () {
    # check if the expected arg amount $1 matches the passed arg amount $2
    # usage:
    # __expect 1 "$#" || return 1
    # TODO get args implicit from last command
    echo ${!!$#}
    local params_expected params_given
    arguments_expected="$1"
    arguments_given="$2"
    if [[ "$arguments_expected" == "$arguments_given" ]]
    then
        return 0
    # TODO handle
    elif [[ "$arguments_expected" < "$arguments_given" ]]
    then
        return 0
    else
        echo "$arguments_expected arguments required"
        return 1
    fi
}
test () {
__expect 2
}
#+END_SRC

** functions with keybindings
#+BEGIN_SRC shell
# TODO rm
# example fzf completion https://github.com/junegunn/fzf/wiki/Examples-(completion)
# Custom fuzzy completion for "doge" command
#   e.g. doge **<TAB>
_fzf_complete_doge() {
  _fzf_complete "--multi --reverse" "$@" < <(
    echo very
    echo wow
    echo such
    echo doge
  )
}

# tab completion for the output of the previous command {
_prev_result () {
    local hstring
    hstring=$(eval `fc -l -n -1`)
    set -A hlist ${(@s/
/)hstring}
    compadd - ${hlist}
}

zle -C prev-comp menu-complete _prev_result
# usage
# $ find . -name "settings.py.*"
# $ vim <Escape>e<Tab>
bindkey '\ee' prev-comp
# }

# fzf filter for the output of the previous command {
fzf_filter_prev () {
    local selection
    selection=$(fc -e - | fzf)
    if [[ -a $selection ]]
    then
        smart_open $selection
    fi
}

zle -N fzf_filter_prev
# usage
# $ ls
# $ <Escape>f
bindkey -s '\ef' 'fzf_filter_prev\n'
# }

# open last output {
open_prev () {
    local files
    files=$(fc -e -)
    if [[ -a $files ]]
    then
        smart_open $files
    fi
}

zle -N open_prev
# usage
# $ ls
# $ <Escape>o
bindkey -s '\eo' 'open_prev\n'
# }

# copy the output of the previous command to clipboard {
copy_prev () {
    fc -e - | pbcopy
}

zle -N cp_prev
# usage
# $ ls
# $ <Escape>c
bindkey -s '\ec' 'cp_prev\n'
# }

# tab completion for git status files {
_git_status_files () {
    local files
    files=$(git status --porcelain | awk '{print $2 }')
    # sleep?
    sleep 1
    set -A flist ${(@s/
/)files}
    compadd - ${flist}
}

zle -C git-files menu-complete _git_status_files
# usage
# $ git add <Escape>g<Tab>
bindkey '\eg' git-files
# }

#+END_SRC

** OS
#+BEGIN_SRC shell
function get_shell_integration () {
    # https://www.iterm2.com/documentation-shell-integration.html
    curl -L https://iterm2.com/shell_integration/zsh \
    -o ~dotfiles/zsh/iterm2_shell_integration/iterm2_shell_integration.zsh
}
#+END_SRC
** packages
*** homebrew
#+BEGIN_SRC shell
function bip() {
    # Install (one or multiple) selected application(s)
    # using "brew search" as source input
    # mnemonic [B]rew [I]nstall [P]lugin
    local inst=$(brew search | fzf -m)

    if [[ $inst ]]; then
      for prog in $(echo $inst);
      do; brew install $prog; done;
    fi
}

function bup() {
    # Update (one or multiple) selected application(s)
    # mnemonic [B]rew [U]pdate [P]lugin
    local upd=$(brew leaves | fzf -m)

    if [[ $upd ]]; then
      for prog in $(echo $upd);
      do; brew upgrade $prog; done;
    fi
}
function bcp() {
    # Delete (one or multiple) selected application(s)
    # mnemonic [B]rew [C]lean [P]lugin (e.g. uninstall)
    local uninst=$(brew leaves | fzf -m)

    if [[ $uninst ]]; then
    for prog in $(echo $uninst);
    do; brew uninstall $prog; done;
    fi
}
#+END_SRC

** Internet
#+BEGIN_SRC shell
function chrome_history () {
    # browse chrome history
    local cols sep entry
    cols=$(( COLUMNS / 3 ))
    sep='{{::}}'

    # Copy History DB to circumvent the lock
    # - See http://stackoverflow.com/questions/8936878 for the file path
    cp -f ~/Library/Application\ Support/Google/Chrome/Default/History /tmp/h

    entry=$(sqlite3 -separator $sep /tmp/h \
        "select substr(title, 1, $cols), url
        from urls order by last_visit_time desc" |
    awk -F $sep '{printf "%-'$cols's  \x1b[36m%s\n", $1, $2}' |
    fzf --ansi --multi | sed 's#.*\(https*://\)#\1#')
    echo "$entry"
    open "$entry"
}

function chrome_print_tabs () {
    # list the opened tabs in google chrome
    osascript -e 'set text item delimiters to linefeed' -e'tell app "google chrome" to url of tabs of window 1 as text' | tail -n +1

}

function cat_links () {
    # extract the links from a given url
    __expect 1 "$#" || return 1
    curl "$@" | sed -n 's/.*href="\([^"]*\).*/\1/p'
}

function print_external_ip () {
    # print the external ip
    curl ipecho.net/plain
}
#+END_SRC

** Clipboard
#+BEGIN_SRC shell
clipboard_plain_text () {
    # convert clipboard content to plain text
    pbpaste | textutil -convert txt -stdin -stdout -encoding 30 | pbcopy
}

function clipboard_rm_python () {
    # rm >>> from clipboard entry
    pbpaste | cut -c 4- | pbcopy
}

#+END_SRC
** cd
#+BEGIN_SRC shell
function fdr() {
    # TODO fcd & fcd_up
    # fdr - cd to selected parent directory
    local declare dirs=()
    get_parent_dirs() {
      if [[ -d "${1}" ]]; then dirs+=("$1"); else return; fi
      if [[ "${1}" == '/' ]]; then
        for _dir in "${dirs[@]}"; do echo $_dir; done
      else
        get_parent_dirs $(dirname "$1")
      fi
    }
    local DIR=$(get_parent_dirs $(realpath "${1:-$PWD}") | fzf-tmux --tac)
    cd "$DIR"
}
#+END_SRC

** Print / echo

#+BEGIN_SRC shell
function cat_human_time () {
    # print unix timestamps in human readable form
    __expect 1 "$#" || return 1
    perl -lne 'm#: (\d+):\d+;(.+)# && printf "%s :: %s\n",scalar localtime $1,$2' "$1"
}

function tac () {
    # reverse line order of file
    __expect 1 "$#" || return 1
    sed '1!G;h;$!d' "$@"
}

function print_timestamp () {
    echo $(date +%Y-%m-%d-%H-%M-%S)
}

function print_datestamp () {
    echo $(date +%Y-%m-%d)
}

#+END_SRC

** List
TODO wrapper function for single & multiple files
#+BEGIN_SRC shell
  # TODO fzf
  function li () {
      # print the latest file or dir in $1
      local idx dir
      # no params: dir=pwd
      if [ $# -eq 0 ]; then dir="$(pwd)"; else dir="$1" fi
      # no index: index=last
      if [ -z "$2" ]; then idx="1"; else idx="$2"; fi
      (cd "$dir" && realpath "$(ls -1t | head -n$idx | tail -1)")
  }

  function gru () {
      # print the git remote url
      git config --get remote.origin.url
  }

  function gbn () {
      # print the git branch name
      git branch|grep "\*"|awk '{print $2}'
  }

  lscat () {
      # print a separated list of files in dir $1
      local dir
      if [ $# -eq 0 ]; then dir="$(pwd)"; else dir="$1" fi
      find "$dir" -maxdepth 1 -type f -print | while read -r d
      do
          echo ""
          echo "=-=-= $d =-=-="
          echo "------------------------------------------------"
          echo ""
          pygmentize "$d" || cat "$d"
          echo ""
      done
  }

  count_files () {
      # count files in dir $1
      local dir
      if [ $# -eq 0 ]; then dir="$(pwd)"; else dir="$1" fi
      for d in $(find "$dir" -type d -print);
      do
          files=$(find "$d" -maxdepth 1 -type f | wc -l )
          echo "$d : $files"
      done
  }
#+END_SRC

** File

** Modify
#+BEGIN_SRC shell
function kill_lines_containing () {
    # delete lines containing pattern $1 in file $2
    if [ $# -lt 2 ]; then echo "Usage: kill_lines_containing <PATTERN> <FILE>"; return 1; fi
    sed -i '' "/$1/d" "$2"
}

#+END_SRC
** Find
** Select / filter
# TODO Searching file contents
# grep --line-buffered --color=never -r "" * | fzf
# # with ag - respects .agignore and .gitignore
# ag --nobreak --nonumbers --noheading . | fzf
#+BEGIN_SRC shell
function fli () {
    # (fzf-)filter file in a given directory (sorted by dates)
    if [ $# -eq 0 ]; then echo "Argument required"; return 1; fi
    (cd "$1" && realpath "$(ls -1t | fzf)")
}
#+END_SRC

** Directory
** Operations / actions                                             :plugin:
#+BEGIN_SRC shell
function redirect_top () {
    # 
    touch ~tmp/redirect_top_tmp && rm ~tmp/redirect_top_tmp
    echo -e "$1" | cat - "$2" > ~tmp/redirect_top_tmp && mv ~tmp/redirect_top_tmp "$2"
    # echo -e "task goes here\n$(cat todo.txt)" > todo.txt
}
#+END_SRC
** old
  # functions {{{
# tools {
print_shrug () {
    echo "¬Ø\\_(„ÉÑ)_/¬Ø"
}
print_python_kws () {
    python -c "import keyword
for kw in keyword.kwlist:
print(kw)"
}
mk_zip_bomb () {
    dd if=/dev/zero bs=1M count=10240 | gzip > 10G.gzip
}
list_background_images () {
    local url=$1
    curl $url|awk -F\" '{for(i=0;++i<=NF;){if($i ~ /^http/ && $i !~ "google\|cache:"){print $i}}}'|grep '.*\.\(jpg\|JPG\|png\|PNG\|gif\|GIF\)'
}
# }
# fileoperations {
rename_prefix_iterator () {
local prefix=$1
local pattern=$2
i=1
for file in *$pattern*; do
    filename=$(basename "$file")
    extension="${filename##*.}"
    filename="${filename%.*}"
    cp $file $(printf "$prefix-%0.3d.$extension" $i)
    i=$((i + 1))
done
}
# }
# echo {
# 
# get the last file of the given directory
echo_lf () {
echo "$1/$(ls -1t $1/ | head -n1)"
}
# }

# list {

recipes () {
(cd ~org/rezepte && ls -1a|sed -e 's/\.org//g' -e 's/_/ /g')
}
escape_spaces () {
echo "${(q)1}"
}
# print a directory tree
dir_tree () {
ls -R | grep ":$" | sed -e 's/:$//' -e 's/[^-][^\/]*\//--/g' -e 's/^/   /' -e 's/-/|/'
}

# ff:  find a file under the current directory
ff () { /usr/bin/find . -name "$@" ; }

# ff:  fuzzy find file under the current directory
fff () { /usr/bin/find . -name "*$@*" ; }

# ffs: to find a file whose name starts with a given string
ffs () { /usr/bin/find . -name "$@"'*' ; }

# ffe: to find a file whose name ends with a given string
ffe () { /usr/bin/find . -name '*'"$@" ; }

# fd: find a directory
fd () { /usr/bin/find . -type d -name '*'"$@" ; }

# ffd: fuzzy find a directory
ffd () { /usr/bin/find . -type d -name "*$@*" ; }

# ffg:  to find a file under the current git directory
ffg () { /usr/bin/find `git rev-parse --show-toplevel` -name "$@" ; }

# ffsg: to find a file whose name starts with a given string within the current git dir
ffsg () { /usr/bin/find `git rev-parse --show-toplevel` -name "$@"'*' ; }

# ffeg: to find a file whose name ends with a given string within the current git dir
ffeg () { /usr/bin/find `git rev-parse --show-toplevel` -name '*'"$@" ; }

# fdg: find a directory within the current git dir
fdg () { /usr/bin/find `git rev-parse --show-toplevel` -type d -name '*'"$@" ; }

# ag within the git dir
agg () { /usr/local/bin/ag "$@" `git rev-parse --show-toplevel` ; }
gagg () { agg "$@" ; }

# search for a file using Spotlight's metadata
spotlight () { mdfind "kMDItemDisplayName == '$@'wc"; }

# TODO FIXME
f_spotlight () {
smart_open $(spotlight "$@" | fzf --select-1)
}

# show the SpotLight comment for a file
spotlight_comment () { mdls "$1" | grep kMDItemFinderComment ; }

# locaterecent: to search for files created since yesterday using Spotlight
# this is an illustration of using $time in a query
# see: http://developer.apple.com/documentation/Carbon/Conceptual/SpotlightQuery/index.html
# TODO: day param
spotlight_recent_created () {
mdfind 'kMDItemFSCreationDate >= $time.yesterday' | sed '/^\/Users\/mbayer\//!d' | sed '/^\/Users\/mbayer\/Library\//d' | sed '/pyc$/d'
}

mru () {
find ~ \( -path '*/\.*' -o -path '/Users/mbayer/Library*' -o -path '/Users/mbayer/Pictures/Fotos-Mediathek.photoslibrary*' -o -path '/Users/mbayer/Workspace/Envs*' \) -prune -o \( -name '*\.pyc' \) -prune -o -type f -mtime -7 -perm -g+r,u+r,o+r -print | sed '/Dropbox.*Icon*/d'
}

f_mru () {
smart_open $(mru | fzf)
}

# list_all_apps: list all applications on the system
list_all_apps () { mdfind 'kMDItemContentTypeTree == "com.apple.application"c' ; }

# find_larger: find files larger than a certain size (in bytes)
find_larger () { /usr/bin/find . -type f -size +${1}c ; }

# findword: search for a word in the Unix word list
findword () { /usr/bin/grep ^"$@"$ /usr/share/dict/words ; }

# dictionary lookup
# dict_lookup is a python script which queries osx dict
dict () {
dict_lookup "$@"|tr '|' '\n'|sed 's/^ //g'
}

# fzf {
# open screenshot
f_screenshot () {
    local screenshot_path screenshot
    screenshot_path="$HOME/Pictures/Screenshots"
    out=$(ls -r ${screenshot_path} | grep Bildschirmfoto | fzf --expect=ctrl-y)
    key=$(head -1 <<< "$out")
    screenshot=$(head -2 <<< "$out" | tail -1)
    echo "$screenshot_path/${(q)screenshot}"
    [ "$key" = ctrl-y ] && echo "$screenshot_path/${(q)screenshot}" | pbcopy || $(open $screenshot_path/$screenshot)
}

# fzf open
# fe [FUZZY PATTERN] - Open the selected file with the default editor
#   - Bypass fuzzy finder if there's only one match (--select-1)
#   - Exit if there's no match (--exit-0)
# you can press
#   - CTRL-O to open with `open` command,
#   - CTRL-E or Enter key to open with the $EDITOR
f_open () {
    local out file key
    out=$(fzf --query="$1" --exit-0 --select-1 --exit-0 --cycle --expect=ctrl-o,ctrl-e --preview "head -$LINES {}")
    key=$(head -1 <<< "$out")
    file=$(head -2 <<< "$out" | tail -1)
    if [ -n "$file" ]; then
        # [ "$key" = ctrl-o ] && open "$file" || eval ${EDITOR_TAB} "$file"
        [ "$key" = ctrl-o ] && open "$file" || smart_open "$file"
        # echo "$file"
    fi
}
alias fo='f_open'

# open a file at path
fo_at () {
    (cd "$1" && fo)
}

# open a file under a hashed path
f_hash () {
    local scope=$(hash -d | grep -v '_' | sed 's/=.*//' | grep "$1")
    if [[ "$scope" != "" ]]; then
        local hash_path=$(hash -d | grep -v '_' | sed 's/.*=//' | grep "$scope")
        (cd "$hash_path" && fo)
    else
        echo "unknown hash: $1"
    fi
}

org () { (cd ~org && fo "$1") }
dotfile () { (cd ~dotfiles && fo "$1") }
gist () { (cd ~gists && fo "$1") }
gist_search () { (cd ~gists && ag -C 5 "$1") }

# fzf cd - cd to selected directory
f_cd () {
    local dir
    dir=$(/usr/bin/find ${1:-*} -path '/*/\.*' -prune \
                    -o -type d -print 2> /dev/null | fzf +m) &&
    realpath "$dir"
    cd "$dir"
}
alias fcd='f_cd'

# fcd starting from $HOME
f_gcd () {
    local dir
    dir=$(/usr/bin/find ${1:-*} -path $(echo $HOME)'/*/\.*' -prune \
                    -o -type d -print 2> /dev/null | fzf +m) &&
    cd "$dir"
}
alias fgcd='f_cd'

f_dirs () {
    local dir
    dir=$(dirs | awk '{print $2}' | fzf)
    dn=$(dirname "$dir")
    echo $dn
    cd $dn
}

# search for file contents
f_ag () {
    ag "$1" --nobreak --nonumbers --noheading . | fzf
}
alias fag='f_ag'

# fbr - checkout git branch (including remote branches)
f_git_checkout () {
    local branches branch
    branches=$(git branch --all | grep -v HEAD) &&
    branch=$(echo "$branches" |
            fzf-tmux -d $(( 2 + $(wc -l <<< "$branches") )) +m) &&
    git checkout $(echo "$branch" | sed "s/.* //" | sed "s#remotes/[^/]*/##")
}

# fco - checkout git branch/tag
f_git_checkout_tag () {
    local tags branches target
    tags=$(
    git tag | awk '{print "\x1b[31;1mtag\x1b[m\t" $1}') || return
    branches=$(
    git branch --all | grep -v HEAD             |
    sed "s/.* //"    | sed "s#remotes/[^/]*/##" |
    sort -u          | awk '{print "\x1b[34;1mbranch\x1b[m\t" $1}') || return
    target=$(
    (echo "$tags"; echo "$branches") |
    fzf-tmux -l30 -- --no-hscroll --ansi +m -d "\t" -n 2) || return
    git checkout $(echo "$target" | awk '{print $2}')
}

# fcoc - checkout git commit
f_git_checkout_commit () {
    local commits commit
    commits=$(git log --pretty=oneline --abbrev-commit --reverse) &&
    commit=$(echo "$commits" | fzf --tac +s +m -e) &&
    git checkout $(echo "$commit" | sed "s/ .*//")
}

# fshow - git commit browser
f_git_log () {
    git log --graph --color=always \
        --format="%C(auto)%h%d %s %C(black)%C(bold)%cr" "$@" |
    fzf --ansi --no-sort --reverse --tiebreak=index --bind=ctrl-s:toggle-sort \
        --bind "ctrl-m:execute:
                (grep -o '[a-f0-9]\{7\}' | head -1 |
                xargs -I % sh -c 'git show --color=always % | less -R') << 'FZF-EOF'
                {}
FZF-EOF"
}

# pick a container id from all containers
f_docker_container_id () {
    local selection c_id
    selection=$(docker ps -a | fzf --reverse --header-lines=1 --prompt="üê≥  ")
    c_id=$(echo $selection | awk '{print $1}')
    echo $c_id | pbcopy
    echo "copied:"
    echo $c_id
}

f_docker_exec_select () {
    local selection c_id cmd
    selection=$(docker ps | fzf --reverse --header-lines=1 --prompt="üê≥  ")
    c_id=$(echo $selection | awk '{print $1}')
    cmd="docker exec -it $c_id /bin/bash"
    echo $cmd
    eval $cmd
}
alias docker_shell='f_docker_exec_select'

# pick a container id from all running containers
f_docker_container_running_id () {
    local selection c_id
    selection=$(docker ps | fzf --reverse --header-lines=1 --prompt="üê≥  ")
    c_id=$(echo $selection | awk '{print $1}')
    echo $c_id | pbcopy
    echo "copied:"
    echo $c_id
}

# pick an image name
f_docker_image_name () {
    local selection c_id
    selection=$(docker ps -a | fzf --reverse --header-lines=1 --prompt="üê≥  ")
    c_id=$(echo $selection | awk '{print $2}')
    echo $c_id | pbcopy
    echo "copied:"
    echo $c_id
}

# c - browse chrome history
f_chrome_history () {
        local cols sep
        cols=$(( COLUMNS / 3 ))
        sep='{{::}}'

        # Copy History DB to circumvent the lock
        # - See http://stackoverflow.com/questions/8936878 for the file path
        cp -f ~/Library/Application\ Support/Google/Chrome/Default/History /tmp/h

        sqlite3 -separator $sep /tmp/h \
        "select substr(title, 1, $cols), url
        from urls order by last_visit_time desc" |
        awk -F $sep '{printf "%-'$cols's  \x1b[36m%s\n", $1, $2}' |
        fzf --ansi --multi | sed 's#.*\(https*://\)#\1#' | xargs open
}
alias chrome_history='f_chrome_history'

# browse chrome bookmarks
f_chrome_bookmarks () {
    $HOME/Workspace/scripts/fzf_chrome_bookmarks.rb
}
alias chrome_bookmarks='f_chrome_bookmarks'
# }
# }

# print {
# pretty print json
# pjson '{"test": "test"}'
# pjson myjsonfile.json
# pjson '{"test": "test"}' myjsonfile.json
pjson () {
if [ $# -gt 0 ];
    then
    for arg in $@
    do
        if [ -f $arg ];
            then
            less $arg | python -m json.tool
        else
            echo "$arg" | python -m json.tool
        fi
    done
fi
}
# }

# vim {
smart_open () {
# escape spaces
local filename cmd cmd_dir cmd_text cmd_arbitrary
filename=${(q)1}

cmd=""
cmd_dir="cd $filename"
cmd_text="${EDITOR_TAB} $filename"
cmd_arbitrary="open $filename"

# if directory
if [[ -d "$filename" ]]; then
    cmd=$cmd_dir
else
    # special case handling
    local file_extension file_exceptions
    file_extension="${filename##*.}"
    file_exceptions=(csv org)
    for i in "${file_exceptions[@]}"
    do
        if [[ "$i" == "$file_extension" ]]; then
            cmd=$cmd_arbitrary
        fi
    done

    # skip if it was special case
    if [[ "$cmd" == "" ]]; then
        # if meta information is text
        if [[ $(file "$filename" | awk '{print $NF}') == 'text' ]]; then
            cmd=$cmd_text
        else
            # fallback
            cmd=$cmd_arbitrary
        fi
    fi
fi

if [[ $cmd != '' ]]; then
    echo $filename
    eval ${cmd}
else
    echo "nothing to do here"
fi
}

# open files from asgard
asgard_open () {
mvim -c "echo :set buftype: \" \"" --remote-tab-silent scp://asgard//"$@"
}

# start vim with python 2 venv then switch back
pvim () {
venv="${VIRTUAL_ENV##*/}"
if [[ $venv != "" ]]
then
    workon python2.7.5
    mvim
    workon $venv
else
    mvim
fi
}
# }

# emacs {
emacs () {
if [ $# -eq 0 ]; then
    # open -a /usr/local/Cellar/emacs/25.2/Emacs.app/
    eval ${EDITOR}
    return 0
fi
if [ "$1" = "--debug-init" ]; then
    eval ${EDITOR} --args --debug-init
    return 0
fi
for var in "$@"; do
    touch "$var"
    eval "${EDITOR} $var"
done
}
alias e='emacs'

tangle () {
FILE=$(realpath $1)
open -a /usr/local/Cellar/emacs/25.2/Emacs.app --args --eval "(progn
    (require 'org)
    (find-file (expand-file-name \"$FILE\"))
    (org-babel-tangle))"
}

old () {
rm ~/.zshrc
ln -s ~dotfiles/zshrc.zsh ~/.zshrc
}

new () {
rm ~/.zshrc
ln -s ~dotfiles/zsh.zsh ~/.zshrc
}

# }

# vim {
vim () {
if [ $# -eq 0 ]; then
    # open -a Emacs.app
    eval ${VIM_EDITOR}
    return 0
fi

eval ${VIM_EDITOR_TAB} "$@"
}
# }

# git {
# git diff
gd () {
git diff --color $1 $2|diff-so-fancy
}

# git add
ga () {
git add $@
}

# git commit -m
gc () {
git commit -m "$@"
}

# cd to git root
cdg () {
cd `git rev-parse --show-toplevel`
}

# git status file list
git_status_files () {
git status --porcelain | awk '{print $2 }'
}

# show which branch the current one is forked from
git_parent_branch () {
local current_branch=`git rev-parse --abbrev-ref HEAD`
git show-branch -a | ack '\*' | ack -v "$current_branch" | head -n1 | sed 's/.*\[\(.*\)\].*/\1/' | sed 's/[\^~].*//'
}

# list git tree
git_tree () {
(git ls-tree -r --name-only HEAD || /usr/bin/find . -path "*/\.*" -prune -o -type f -print -o -type l -print | sed s/^..//) 2> /dev/null
}


# pull all repositories under $pwd
# git_pull_rec () {
#     /usr/bin/find . -type d -depth 1 -exec git --git-dir={}/.git --work-tree=$PWD/{} pull origin master \;
# }

# git push -u origin {BRANCH_NAME}
git_push_branch () {
git push -u origin "$(git branch --no-color | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')"
}

# show the git log as json
git_log_json () {
git log --pretty=format:'{%n  "commit": "%H",%n  "abbreviated_commit": "%h",%n  "tree": "%T",%n  "abbreviated_tree": "%t",%n  "parent": "%P",%n  "abbreviated_parent": "%p",%n  "refs": "%D",%n  "encoding": "%e",%n  "subject": "%s",%n  "sanitized_subject_line": "%f",%n  "body": "%b",%n  "commit_notes": "%N",%n  "verification_flag": "%G?",%n  "signer": "%GS",%n  "signer_key": "%GK",%n  "author": {%n    "name": "%aN",%n    "email": "%aE",%n    "date": "%aD"%n  },%n  "commiter": {%n    "name": "%cN",%n    "email": "%cE",%n    "date": "%cD"%n  }%n},'
}

# open a gist repository in the browser
git_gist_remote_url () {
local gist_url
gist_url="https://gist.github.com/embayer/"$(git config --get remote.origin.url | cut -c24- | sed 's/\.git$//')
echo "$gist_url"
open "$gist_url"
}
# }

# docker {
# regiobot {
# init regiobot docker
rg_init () {
    cd ~/Workspace/regiobot/regiobot/
    docker-machine stop regiobot
    docker-machine start regiobot
    eval "$(docker-machine env regiobot)"
    make up
}

# open a bash session in the regiobot docker
rg_shell () {
    eval "$(docker-machine env regiobot)"
    docker exec -it $(docker ps | awk '{ if ($2 == "regiobot_django") print $1 }') /bin/bash
}

import_shell () {
    eval "$(docker-machine env regiobot)"
    docker exec -it $(docker ps | awk '{ if ($2 == "rgimport_rgimport") print $1 }') /bin/bash
}
# }
# }

# trac {
# cartman wrapper
trac () {
$WORKON_HOME/python2.7.5/bin/cm "$@" 2>/dev/null
}

# comment on a ticket
trac_comment () {
# trac_comment {ticket_nr} "{comment}"
trac comment "$1" -m "$2"
}

# view ticket status
trac_status () {
trac status "$@"
}

# accept a ticket
trac_accept () {
trac status "$1" accept
}

# view a ticket by nr
# -o -> open in browser
trac_view () {
local ticket_nr
ticket_nr=$1
if [[ ! $ticket_nr == '' ]]; then
    local ticket_url
    ticket_url=https://trac.inquant.de/regioyal/ticket/$ticket_nr

    if [[ "$2" == "-o" ]]; then
        echo "üêæ  $ticket"
        echo "üîó  $ticket_url"
        open https://trac.inquant.de/regioyal/ticket/$ticket_nr
    else
        local ticket_description
        ticket_description=`trac view $ticket_nr`
        echo "üêæ  $ticket_description"
        echo ""
        echo ""
        echo "------------------------------------------------"
        echo "üîó  $ticket_url"
    fi
fi
}

# search ticket titles via https://pypi.python.org/pypi/cartman/0.2.3
trac_ticket () {
    local ticket ticket_nr
    # sort numerical
    ticket=$(trac report 3 | sort -t '#' -k 2n | fzf)
    ticket_nr=`echo $ticket | awk '{print $1}' | sed 's/[^0-9]*//g'`

    if [[ ! $ticket_nr == '' ]];then
        trac_view $ticket_nr $1
    fi
}

# search tickets (trac_search "404 pages" -o)
trac_search () {
    local ticket ticket_nr
    ticket=$(trac search "$1" | fzf)
    ticket_nr=`echo $ticket | awk '{print $1}' | sed 's/[^0-9]*//g'`

    if [[ ! $ticket_nr == '' ]];then
        local last_param
        eval last_param=\$$#
        if [[ $last_param == '-o' ]];then
            trac_view $ticket_nr $last_param
        else
            trac_view $ticket_nr
        fi
    fi
}
# }

# actions {

# convert all xlsx files in pwd to csv
# pip install xlsx2csv required
xlsx2csv_in_dir () {
for filename in ./*.xlsx; do xlsx2csv $filename ${filename:r}.csv; done
}
# colored man pages
man () {
env \
LESS_TERMCAP_mb=$(printf "\e[1;31m") \
LESS_TERMCAP_md=$(printf "\e[1;31m") \
LESS_TERMCAP_me=$(printf "\e[0m") \
LESS_TERMCAP_se=$(printf "\e[0m") \
LESS_TERMCAP_so=$(printf "\e[1;44;33m") \
LESS_TERMCAP_ue=$(printf "\e[0m") \
LESS_TERMCAP_us=$(printf "\e[1;32m") \
    man "$@"
}


diff_sorted () {
diff <(sort "$1") <(sort "$2")
}

# escape spaces
esc () {
echo ${(q)@}
}

# print time logged in
print_uptime () {
last | grep `whoami` | grep -v logged | cut -c61-71 | sed -e 's/[()]//g' | awk '{ sub("\\+", ":");split($1,a,":");if(a[3]){print a[1]*60*60+a[2]*60+a[3]} else {print a[1]*60+a[2] }; }' | paste -s -d+ - | bc | awk '{printf "%dh:%dm:%ds\n",$1/(60*60),$1%(60*60)/60,$1%60}'
}


# print a divider
div () {
echo ""
imgcat ~dropbox/Bilder/Art/MC-Escher-Metamorphosis.jpg
}
# create an executable script
mk_script () {
(($# > 0)) && {
    touch "$1"
    chmod +x "$1"
    eval ${EDITOR_TAB} "$1"
}
}

mkdir_cd () {
mkdir $1 && cd $_
}
alias mkcd='mkdir_cd'

# move file/dir to trash
trash () { mv "$@" $HOME/.Trash/. ; }

# backup the current directory at the parent directoy
# use encryption with -e
bu () {
dname=$(basename $(pwd))
cd ..
if [[ "$1" == "-e" ]]; then
    buname=$dname""_$(date +%d%m%y-%H-%M-%S).tar.gz.enc
    tar cz "$dname/" | openssl enc -aes-256-cbc -e > "$buname"
else
    buname=$dname""_$(date +%d%m%y-%H-%M-%S).tar.gz
    tar czf "$buname" "$dname/"
fi
echo "-> ../$buname"
cd -  >/dev/null 2>&1
}

# convert a given zshmarks bookmarks file to zsh named directories
bookmarks_to_hashes () {
cat "$@" | awk '(FS = "|") && (NF) { gsub(/\$HOME/, "~", $1); print "hash -d " $2 "=" $1 }'
}

# lookup dict.cc
de () { dict.cc.py de en "$1"; }
# lookup dict.cc for english words
en () { dict.cc.py en de "$1"; }

# copy the current working dir to clipboard
copy_pwd () { pwd | pbcopy }

# copy the last command to clipboard
copy_last_cmd () {
# echo "!!" | pbcopy
history | tail -1 | awk '{for (i=2; i<NF; i++) printf $i " "; print $NF}' | pbcopy
}

# calculator
= () {
calc="${@//p/+}"
calc="${calc//x/*}"
echo "$(($calc))"
}

# show clock
clock () {
while sleep 1;do tput sc;tput cup 0 $(($(tput cols)-29));date;tput rc;done &
}

# explain tools
explain () {
if [ "$#" -eq 0 ]; then
while read  -p "Command: " cmd; do
    curl -Gs "https://www.mankier.com/api/explain/?cols="$(tput cols) --data-urlencode "q=$cmd"
done
echo "Bye!"
elif [ "$#" -eq 1 ]; then
curl -Gs "https://www.mankier.com/api/explain/?cols="$(tput cols) --data-urlencode "q=$1"
else
echo "Usage"
echo "explain                  interactive mode."
echo "explain 'cmd -o | ...'   one quoted command to explain it."
fi
}

# osx {
pomodoro () {
    # TODO: tags, exercises, postpone
    # Basso.aiff  Blow.aiff  Bottle.aiff  Frog.aiff  Funk.aiff  Glass.aiff  Hero.aiff  Morse.aiff  Ping.aiff  Pop.aiff  Purr.aiff  Sosumi.aiff  Submarine.aiff  Tink.aiff
    local title="Pomodoro"
    local subtitle="time for a break"
    local soundname="Hero"
    if [[ "$1" == "" ]]; then
        local notification="a task"
    else
        local notification="$1"
    fi
    local timestamp=$(date +%d.%m.%Y-%H:%M:%S)
    # TODO: display end time
    echo "$timestamp\t$notification""\r"
    echo "$timestamp\t$notification""\r" >> ~/.pomodoro

    local secs=$((1))
    # display a timer
    while [ $secs -gt 0 ]; do
        # TODO: format minutes
        echo -ne "$secs\033[0K\r"
        sleep 1
        : $((secs--))
    done
    echo "display notification \"$notification\" with title \"$title\" subtitle \"$subtitle\" sound name \"$soundname\""
    osascript -e "display notification \"$notification\" with title \"$title\" subtitle \"$subtitle\" sound name \"$soundname\""
}
alias pom='pomodoro'
pomo () {
    blocks
    pomodoro "$1"
    blocks
}

pomodoro_today () {
    local pomodoros=$(grep -o "$(date +%d.%m.%Y)" ~/.pomodoro | wc -l|awk '{print $1}')
    echo "$pomodoros pomodoros today: ${(l:$pomodoros::üçÖ:)}\n"
    cat ~/.pomodoro | grep "$(date +%d.%m.%Y)" --color=never | cut -c 12-
}

# say
# test voices
say_test () {
    say -v '?' | awk '{print $1}' | while read voice; do printf "using $voice...\n"; say -v $voice "hello, this is me using the $voice voice"; sleep 1; done
}

lol () { say -v Hysterical 'hahahahahahaha oh really?' }

sing_song () {
    songs=(
        "say -v Alex Dum dum dee dum dum dum dum dee Dum dum dee dum dum dum dum dee dum dee dum dum dum de dum dum dum dee dum dee dum dum dee dummmmmmmmmmmmmmmmm" \
        "say -v Anna di di di di di di di di di di di di di di di di di di di di di di di di di di" \
        "say -v Cellos oh This is a ponci song ponci song ponci song this is the ponsiano song ive ever ever heard So why keep you listening listening listening while you are supposed to hack to hack to hack to hack its because i hate bill gates hate bill gates hate bill gates its because i hate bill gates more than anything else No its because windows life windows life windows life and you better get a macintosh and iPod now" \
        "say -v Good oooooooooooooooooooooooooooooooooooooooo¬≠oooooooooooooooooooooooooooooooooooooooo¬≠oooooooooooooooooooo oooooooooooooooooooooooooooooooooooooooo¬≠oooooooooooooooooooooooooooooooooooooooo¬≠oooooooooooooooooooo oooooooooooooooooooooooooooooooooooooooo¬≠oooooooooooooooooooooooooooooooooooooooo¬≠oooooooooooooooooooo oooooooooooooooooooooooooooooooooooooooo¬≠oooooooooooooooooooooooooooooooooooooooo¬≠oooooooooooooooooooo oooooooooooooooooooooooooooooooooooooooo¬≠oooooooooooooooooooooooooooooooooooooooo¬≠oooooooooo" \
        "say -v Bad oooooooooooooooooooooooooooooooooooooooo¬≠oooooooooooooooooooooooooooooooooooooooo¬≠oooooooooooooooooooo oooooooooooooooooooooooooooooooooooooooo¬≠oooooooooooooooooooooooooooooooooooooooo¬≠oooooooooooooooooooo oooooooooooooooooooooooooooooooooooooooo¬≠oooooooooooooooooooooooooooooooooooooooo¬≠oooooooooooooooooooo oooooooooooooooooooooooooooooooooooooooo¬≠oooooooooooooooooooooooooooooooooooooooo¬≠oooooooooooooooooooo oooooooooooooooooooooooooooooooooooooooo¬≠oooooooooooooooooooooooooooooooooooooooo¬≠oooooooooo")
    ponysay $songs[$1]
    eval ${songs[$1]}
}

# set alarm clock with say
alarm_msg () {
    echo "alarm in ""$1""m"
    local secs=$(($1 * 60))
    # display a timer
    while [ $secs -gt 0 ]; do
        # TODO: format minutes
        echo -ne "$secs\033[0K\r"
        sleep 1
        : $((secs--))
    done

    say -v Zarvox "$2"
}
alarm () {
    echo "alarm in ""$1""m"
    local secs=$(($1 * 60))
    # display a timer
    while [ $secs -gt 0 ]; do
        # TODO: format minutes
        echo -ne "$secs\033[0K\r"
        sleep 1
        : $((secs--))
    done
    sing_song 1
}
# eject all mountable volumes
eject () {
    osascript -e 'tell application "Finder" to eject (every disk whose ejectable is true)'
}

# change working directory to Finder path
cdf () {
    cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')"
}

# toggle show/hide hidden files in finder
toggle_hidden () {
    isVisible=$(defaults read com.apple.finder AppleShowAllFiles)

    # toggle visibility based on variables value
    if [ ${isVisible} = FALSE ]
    then
        defaults write com.apple.finder AppleShowAllFiles TRUE
    else
        defaults write com.apple.finder AppleShowAllFiles FALSE
    fi

    # force changes by restarting Finder
    killall Finder
}
# }

# archives {
# zipf: to create a ZIP archive of a file or folder
zipf () { zip -r "$1".zip "$1" ; }

# extract an archive
# TODO target
extract () {
    if [ -f $1 ] ; then
        case $1 in
            ,*.tar.bz2)  tar xjf $1      ;;
            ,*.tar.gz)   tar xzf $1      ;;
            ,*.bz2)      bunzip2 $1      ;;
            ,*.rar)      rar x $1        ;;
            ,*.gz)       gunzip $1       ;;
            ,*.tar)      tar xf $1       ;;
            ,*.tbz2)     tar xjf $1      ;;
            ,*.tgz)      tar xzf $1      ;;
            ,*.zip)      unzip $1        ;;
            ,*.Z)        uncompress $1   ;;
            ,*)          echo "'$1' cannot be extracted via extract()" ;;
    esac
    else
        echo "'$1' is not a valid file"
    fi
}
# }

# network {
# serve wd
serve () {
    printip
    # TODO check version
    # python 2
    # python -m SimpleHTTPServer
    python3 -m http.server
}

serve_bash () {
    printip | awk '{print $1":8080"}'
    while true; do { echo -e 'HTTP/1.1 200 OK\r\n'; \
    cat "$1"; } | nc -l 8080; done
}

# open a url
op () {
    typeset -A mapping
    mapping=(
        google https://www.google.de/
        spotify https://play.spotify.com/collection/songs
    )
    open $mapping[$@]
}
# }

# color {
# show available color codes
typeset -Ag FX FG BG

FX=(
    reset     "%{[00m%}"
    bold      "%{[01m%}" no-bold      "%{[22m%}"
    italic    "%{[03m%}" no-italic    "%{[23m%}"
    underline "%{[04m%}" no-underline "%{[24m%}"
    blink     "%{[05m%}" no-blink     "%{[25m%}"
    reverse   "%{[07m%}" no-reverse   "%{[27m%}"
)

for color in {000..255}; do
    FG[$color]="%{[38;5;${color}m%}"
    BG[$color]="%{[48;5;${color}m%}"
done

ZSH_SPECTRUM_TEXT=${ZSH_SPECTRUM_TEXT:-Arma virumque cano Troiae qui primus ab oris}

# Show all 256 colors with color number
spectrum_ls () {
    for code in {000..255}; do
    print -P -- "$code: %F{$code}$ZSH_SPECTRUM_TEXT%f"
    done
}

# Show all 256 colors where the background is set to specific color
spectrum_bls () {
    for code in {000..255}; do
    print -P -- "$BG[$code]$code: $ZSH_SPECTRUM_TEXT %{$reset_color%}"
    done
}

# TODO bold
# }

# fun {
# nyan cat
nyan () { telnet nyancat.dakko.us }

# starwars
starwars () { telnet towel.blinkenlights.nl }

# mandelbrot
mandelbrot () {
    local lines columns colour a b p q i pnew
    ((columns=COLUMNS-1, lines=LINES-1, colour=0))
    for ((b=-1.5; b<=1.5; b+=3.0/lines)) do
        for ((a=-2.0; a<=1; a+=3.0/columns)) do
            for ((p=0.0, q=0.0, i=0; p*p+q*q < 4 && i < 32; i++)) do
                ((pnew=p*p-q*q+a, q=2*p*q+b, p=pnew))
            done
            ((colour=(i/4)%8))
            echo -n "\\e[4${colour}m "
        done
        echo
    done
}
          # }
      # }
  # }}}


* Keybindings
:PROPERTIES:
:CUSTOM_ID: keybindings
:END:
http://zsh.sourceforge.net/Doc/Release/Zsh-Line-Editor.html

to find out what the terminal emulator sends:
$ cat<RET><key-chard>
if this isn't usable let the terminal emulator send escape codes

Scrolling is done via cmd-up/down
** rebindings
https://stackoverflow.com/questions/21946281/what-is-application-mode-in-terminals-zsh-terminfo
#+BEGIN_SRC shell
# Make sure that the terminal is in application mode when zle is active, since
# only then values from $terminfo are valid
if (( ${+terminfo[smkx]} )) && (( ${+terminfo[rmkx]} )); then
    function zle-line-init() {
        echoti smkx
    }
    function zle-line-finish() {
        echoti rmkx
    }
    zle -N zle-line-init
    zle -N zle-line-finish
fi
#+END_SRC

#+BEGIN_SRC shell
# TODO use terminfo
## movement http://zsh.sourceforge.net/Doc/Release/Zsh-Line-Editor.html#Movement
bindkey '^[^[[D' backward-word                      # alt <arrow-left>............move a word backward
bindkey '^[^[[C' forward-word                       # alt <arrow-right>...........move a word forward
bindkey '^A' beginning-of-line                      # cmd <arrow-left>............move to the beginning of the line
bindkey '^E' end-of-line                            # cmd <arrow-right>...........move to the end of the line
bindkey '^[[1;2B' down-line
bindkey '^[[1;2A' up-line
bindkey '^N' vi-find-next-char

## Modifying-Text http://zsh.sourceforge.net/Doc/Release/Zsh-Line-Editor.html#Modifying-Text
bindkey ';6D' copy-prev-word # ctr shift <-

## kill
bindkey '^[^H' backward-kill-word                   # cmd <del>...................delete the word left of the cursor
bindkey '^[csd' backward-kill-word
bindkey '^X' delete-char                            # ctrl x......................delete the char under the cursor
bindkey '^[csku' kill-line
bindkey '^[k' kill-region
bindkey '^?' backward-delete-char                     # [Backspace] - delete backward
if [[ "${terminfo[kdch1]}" != "" ]]; then
    bindkey "${terminfo[kdch1]}" delete-char            # [Delete] - delete forward
else
    # fixes outputting tildes on <del>
    bindkey "^[[3~" delete-char
    bindkey "^[3;5~" delete-char
    bindkey "\e[3~" delete-char
fi
#bindkey '^[^[[B' kill-whole-line                    # cmd <arrow-down>............delete the whole line

## other
bindkey '^[[5~' up-history
# ctrl s
bindkey '^[cks' accept-and-hold                        # ctrl n .................... multiselect in menu complete
bindkey -s '^[^[[A' 'cd ..\n'                       # alt <arrow-up>..............cd ..
bindkey -s '^L' 'ls -laH\n'                         # ctr l.......................ls -laH
if [[ "${terminfo[kcbt]}" != "" ]]; then
    bindkey "${terminfo[kcbt]}" reverse-menu-complete   # [Shift-Tab] - move through the completion menu backwards
fi

## history
bindkey "$terminfo[kcuu1]" history-substring-search-up
bindkey "$terminfo[kcud1]" history-substring-search-down

## mark
# alt down
bindkey '^[^[[B' set-mark-command
# alt up
bindkey '^[^[[A' deactivate-region
#+END_SRC


** custom zle widgets
https://superuser.com/questions/691925/zsh-how-to-zle-widgets-directly
*** repeat last command
#+BEGIN_SRC shell
function repeat-cmd () {
    # repeat the last command
    zle up-history
    zle accept-line
}

zle -N repeat-cmd
# ctrl l
bindkey '^H' repeat-cmd
#+END_SRC

*** wrap in $()
#+BEGIN_SRC shell
function wrap-call () {
    # wrap the cursor in "$()"
    LBUFFER+="\"\$("
    RBUFFER+=")\""
}

zle -N wrap-call
# esc (
bindkey '^[(' wrap-call
#+END_SRC

*** wrap in ${}
#+BEGIN_SRC shell
function wrap-var () {
    # wrap the cursor in "${}"
    LBUFFER+="\"\${"
    RBUFFER+="}\""
}

zle -N wrap-var
# esc {
bindkey '^[{' wrap-var
#+END_SRC

*** kill first word
#+BEGIN_SRC shell
function kill-first-word () {
    # kill the first word on the cmdline and move cursor to beginning of line
    zle beginning-of-line
    zle forward-word
    zle backward-kill-word
    LBUFFER+=' '
    zle backward-word
}

zle -N kill-first-word
# ctrl shift f
bindkey '^[cskf' kill-first-word
#+END_SRC

*** kill word under cursor
#+BEGIN_SRC shell
function kill-word-under-cursor () {
    # kill the word under the cursor
    zle forward-word
    zle backward-kill-word
}

zle -N kill-word-under-cursor
# ctrl shift w
bindkey '^[cskw' kill-word-under-cursor
#+END_SRC

*** cp cmdline
#+BEGIN_SRC shell
function copy-cmdline-to-clipboard () {
    # Copy the current commandline to the system clipboard
    zle kill-whole-line
    print -rn -- $CUTBUFFER | pbcopy
    zle undo
}

zle -N copy-cmdline-to-clipboard
# esc c
bindkey '^[c' copy-cmdline-to-clipboard
#+END_SRC

**** rationalise dot
#+BEGIN_SRC shell
function rationalise-dot() {
    # expands .... to ../../..
    if [[ $LBUFFER = *.. ]]; then
        LBUFFER+=/..
    else
        LBUFFER+=.
    fi
}
zle -N rationalise-dot
bindkey . rationalise-dot
#+END_SRC

**** path step
#+BEGIN_SRC shell
function backward-delete-path-part () {
    # backward delete until /
    # TODO document
    # local WORDCHARS="${WORDCHARS:s#/#}"
    local WORDCHARS="${WORDCHARS//\/}"
    zle backward-delete-word
}
zle -N backward-delete-path-part
bindkey '^W' backward-delete-path-part
#+END_SRC

* Plugins
:PROPERTIES:
:CUSTOM_ID: plugins
:END:
** zsh-autosuggestions
#+BEGIN_SRC shell
source ~dotfiles/zsh/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh
#+END_SRC

** zsh-history-search-multi-word
https://github.com/zdharma/history-search-multi-word
#+BEGIN_SRC shell
# source ~dotfiles/zsh/plugins/history-search-multi-word/history-search-multi-word.plugin.zsh
#+END_SRC

** zsh-history-substring-search                                     :plugin:
https://github.com/zsh-users/zsh-history-substring-search
#+BEGIN_SRC shell
source ~dotfiles/zsh/plugins/zsh-history-substring-search/zsh-history-substring-search.zsh
#+END_SRC

** fast-syntax-highlighting                                                           :plugin:
https://github.com/zdharma/fast-syntax-highlighting
#+BEGIN_SRC shell
source ~dotfiles/zsh/plugins/fast-syntax-highlighting/fast-syntax-highlighting.plugin.zsh
#+END_SRC

** k                                                                :plugin:
TODO LS_COLORS
https://github.com/supercrabtree/k
#+BEGIN_SRC shell
source ~dotfiles/zsh/plugins/k/k.sh
#+END_SRC

** fzf                                                            :plugin:
https://github.com/junegunn/fzf
https://github.com/junegunn/fzf/wiki

# TODO complete; move to bindings
| shortcut      | action                                                        |
|---------------+---------------------------------------------------------------|
| CTRL-R        | Paste the selected command from history into the command line |
| CTRL-F        | Paste the selected file path(s) into the command line         |
| CTRL-G        | Paste the selected dir path(s) into the command line          |
| CTRL-G CTRL-G | cd into the selected directory                                |
| CTRL-G CTRL-F | git files                                                     |
| CTRL-G CTRL-B | git branches                                                  |
| CTRL-G CTRL-T | git tags                                                      |
| CTRL-G CTRL-R | git remotes                                                   |
| CTRL-G CTRL-H | git commit hashes                                             |

# TODO source out
Solarized colors
  --color=bg+:#073642,bg:#002b36,spinner:#719e07,hl:#586e75
  --color=fg:#839496,header:#586e75,info:#cb4b16,pointer:#719e07
  --color=marker:#719e07,fg+:#839496,prompt:#719e07,hl+:#719e07

Red
--color fg:124,bg:16,hl:202,fg+:214,bg+:52,hl+:231
--color info:52,prompt:196,spinner:208,pointer:196,marker:208

Molokai
--color fg:252,bg:233,hl:67,fg+:252,bg+:235,hl+:81
--color info:144,prompt:161,spinner:135,pointer:135,marker:118

Jellybeans
--color fg:188,bg:233,hl:103,fg+:222,bg+:234,hl+:104
--color info:183,prompt:110,spinner:107,pointer:167,marker:215

JellyX
--color fg:-1,bg:-1,hl:230,fg+:3,bg+:233,hl+:229
--color info:150,prompt:110,spinner:150,pointer:167,marker:174

Seoul256 Dusk
--color fg:242,bg:236,hl:65,fg+:15,bg+:239,hl+:108
--color info:108,prompt:109,spinner:108,pointer:168,marker:168

Seoul256 Night
--color fg:242,bg:233,hl:65,fg+:15,bg+:234,hl+:108
--color info:108,prompt:109,spinner:108,pointer:168,marker:168

Solarized Dark
--color dark,hl:33,hl+:37,fg+:235,bg+:136,fg+:254
--color info:254,prompt:37,spinner:108,pointer:235,marker:235

Solarized Light
--color fg:240,bg:230,hl:33,fg+:241,bg+:221,hl+:33
--color info:33,prompt:33,pointer:166,marker:166,spinner:33

Alternate Solarized Light/Dark Theme
export base03="234"
export base02="235"
export base01="240"
export base00="241"
export base0="244"
export base1="245"
export base2="254"
export base3="230"
export yellow="136"
export orange="166"
export red="160"
export magenta="125"
export violet="61"
export blue="33"
export cyan="37"
export green="64"
 --color fg:-1,bg:-1,hl:$blue,fg+:$base2,bg+:$base02,hl+:$blue
 --color info:$yellow,prompt:$yellow,pointer:$base3,marker:$base3,spinner:$yellow

--color fg:-1,bg:-1,hl:$blue,fg+:$base02,bg+:$base2,hl+:$blue
--color info:$yellow,prompt:$yellow,pointer:$base03,marker:$base03,spinner:$yellow

# TODO keybindings as functions
#+BEGIN_SRC shell
## source completions and bindings
source ~dotfiles/zsh/plugins/fzf/completion.zsh
# https://junegunn.kr/2016/07/fzf-git/
source ~dotfiles/zsh/plugins/fzf/git-completion.zsh
source ~dotfiles/zsh/plugins/fzf/key-bindings.zsh
# TODO steal, fullscreen
source ~dotfiles/zsh/plugins/forgit/forgit.plugin.zsh

## default commands
export FZF_DEFAULT_COMMAND="
    (git ls-tree -r --name-only HEAD \$(git rev-parse --show-toplevel) ||
    rg --files --no-ignore --hidden --follow -g '!{.git,node_modules}/*') 2> /dev/null"

# TODO preview with someting fast, fallback to pygmentize
export FZF_DEFAULT_OPTS="--multi --cycle --select-1 --exit-0
    --border --margin 1% --prompt 'œü ' --no-height --no-reverse
    --color fg:-1,bg:-1,hl:230,fg+:3,bg+:233,hl+:229
    --color info:150,prompt:110,spinner:150,pointer:167,marker:174
    --header='(^start) | (end\$) | (‚Äôexact) | (!not) | OR (^core go\$ | rb\$ | py\$)'
    --preview-window right:40%
    --preview '[[ -d {} ]] && tree -C {} | head -200 ||
               [[ \$(file --mime-type -b {}) =~ image ]] && ls -lah {} && imgcat --256 -w 80 {} 2> /dev/null ||
                 (ls -lah {} &&
                  pygmentize {} ||
                  cat {}) 2> /dev/null | head -500'
    --bind 'ctrl-e:execute(\$EDITOR {})+accept'
    --bind 'ctrl-o:execute(open {})+accept'
    --bind 'ctrl-y:execute(echo {}|pbcopy)+accept'
    --bind 'ctrl-j:jump'"

# to apply the command to CTRL-T as well (CTRL-F in my case)
export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
# TODO get cp working
# export FZF_CTRL_T_OPTS="--bind 'ctrl-x:execute(echo {}|awk '{print \$2}'|pbcopy)+accept'"
#+END_SRC

* Theme
** TODO fzf
** TODO from vim
** TODO basecolor16
#+BEGIN_SRC shell
export PROMPT='%F{green}%n%f@%F{blue}%m%f %F{red}%~ %f% %# '
#+END_SRC

* Original zshrc
:PROPERTIES:
:CUSTOM_ID: original-zshrc
:END:

#+BEGIN_SRC shell :tangle no
  # zsh configs {{{
      # init completion
      autoload -U compinit && compinit
      # enable vcs_info used by the prompt
      autoload -Uz vcs_info
      zstyle ':vcs_info:*' enable git svn
      precmd() { vcs_info }

      # completion {
          # enable vcs_info used by the prompt
          autoload -U compinit && compinit
    
          zstyle ':completion:*' completer _expand _complete
    
          # allow approximate matching
          zstyle ':completion:*' completer _complete _match _approximate
          zstyle ':completion:*:match:*' original only
          # init completion
          autoload -U compinit && compinit
      # #}



      # ls --color
      # LS_COLORS='di=36:ln=35:so=32:pi=33:ex=31:bd=34;46:cd=34;43:su=30;41:sg=30;46:tw=30;42:ow=30;43'
      # LSCOLORS='gxfxcxdxbxegedabagacad'

      # gnu dircolors
      alias dircolors='gdircolors'
      eval `dircolors /Users/mbayer/Settings/dotfiles/monobay.256dark`
  # }}}

  # antigen {{{
      # source $HOME/.oh-my-zsh/custom/plugins/antigen/antigen.zsh
      #
      # # load the oh-my-zsh's library.
      # antigen use oh-my-zsh
      #
      # # bundles from the default repo (robbyrussell's oh-my-zsh).
      # antigen bundle osx
      # antigen bundle brew
      # antigen bundle git
      # antigen bundle python
      # antigen bundle pip
      # antigen bundle docker
      # antigen bundle jsontools
      # antigen bundle urltools
      # antigen bundle web-search
      #
      # # additional bundles
      # antigen bundle zsh-users/zsh-syntax-highlighting
      # antigen bundle zsh-users/zsh-autosuggestions
      # antigen bundle zsh-users/zsh-completions
      # antigen bundle zsh-users/zsh-history-substring-search
      #
      # antigen bundle jocelynmallon/zshmarks
      #
      # # Tell antigen that you're done.
      # antigen apply
  # }}}

  # oh-my-zsh configs {{{

      ZSH=$HOME/.oh-my-zsh

      ZSH_THEME="impure"
      # ZSH_THEME="bay"
      # ZSH_THEME="random"
      CASE_SENSITIVE="false"
      COMPLETION_WAITING_DOTS="false"

      plugins=(
          osx
          brew
          python
          pip
          zshmarks
          pure
          docker
          jsontools
          urltools
          web-search
          zsh-completions
          zsh-syntax-highlighting
          zsh-history-substring-search
          k
          ztrace
          impure)

      source $ZSH/oh-my-zsh.sh
  # }}}

  # plugins-settings {{{
      # fortune ponies {
          fortune | ponysay
      # }

      # fzf {
          source ~/.oh-my-zsh/custom/plugins/fzf/completion.zsh

                  # ag -g "" --path-to-agignore ~/.agignore'
# Feed the output of ag into fzf
alias fzf_ag='ag -g "" | fzf'
          # }
      # }
  # }}}

  # python {{{
      # }
  # }}}

  # docker {{{
      export OSX_PRIVATE=/private
      # $(boot2docker shellinit 2> /dev/null)
      # export DOCKER_HOST=tcp://192.168.59.103:2376
      # export DOCKER_CERT_PATH=$HOME/.boot2docker/certs/boot2docker-vm
      # export DOCKER_TLS_VERIFY=1
  # }}}


  # keybindings / keymappings {{{
      # vi mode
      # bindkey -v

      # TODO: remove
      # bind UP and DOWN arrow keys to history-substring-search
      # zmodload zsh/terminfo
      # bindkey "$terminfo[kcuu1]" history-substring-search-up
      # bindkey "$terminfo[kcud1]" history-substring-search-down

      # widgets
      # _last_command_args() {
      #     last_command=$history[$[HISTCMD-1]]
      #     last_command_array=("${(s/ /)last_command}") 
      #     _sep_parts last_command_array
      # }
      # zstyle ':completion:*' completer _last_command_args _complete


          # tab completion for git status files {
              if [[ $- == *i* ]]; then

                  # CTRL-h - Paste the selected hash(s) into the command line
                  # hash -d | grep -v '_'|awk -F = '{print "~"$1"/""\t\t"$2}'

                  # CTRL-f - Paste the selected file path(s) into the command line
                  __fsel() {
                    local cmd="${FZF_CTRL_T_COMMAND:-"command find -L . \\( -path '*/\\.*' -o -fstype 'dev' -o -fstype 'proc' \\) -prune \
                      -o -type f -print \
                      -o -type d -print \
                      -o -type l -print 2> /dev/null | sed 1d | cut -b3-"}"
                    eval "$cmd" | $(__fzfcmd) -m | while read item; do
                      printf '%q ' "$item"
                    done
                    echo
                  }

                  # CTRL-p - Paste the selected directory path(s) into the command line
                  __fsel-dir() {
                    local cmd="${FZF_ALT_C_COMMAND:-"command find -L . \\( -path '*/\\.*' -o -fstype 'dev' -o -fstype 'proc' \\) -prune \
                      -o -type d -print 2> /dev/null | sed 1d | cut -b3-"}"
                    eval "$cmd" | $(__fzfcmd) -m | while read item; do
                      printf '%q ' "$item"
                    done
                    echo
                  }

                  __fzfcmd() {
                    [ ${FZF_TMUX:-1} -eq 1 ] && echo "fzf-tmux -d${FZF_TMUX_HEIGHT:-40%}" || echo "fzf"
                  }

                  fzf-file-widget() {
                    LBUFFER="${LBUFFER}$(__fsel)"
                    zle redisplay
                  }
                  zle     -N   fzf-file-widget
                  bindkey '^F' fzf-file-widget

                  fzf-dir-widget() {
                    LBUFFER="${LBUFFER}$(__fsel-dir)"
                    zle redisplay
                  }
                  zle     -N   fzf-dir-widget
                  bindkey '^P' fzf-dir-widget

                  # Ctrl-g - cd into the selected directory
                  fzf-cd-widget() {
                    local cmd="${FZF_ALT_C_COMMAND:-"command find -L . \\( -path '*/\\.*' -o -fstype 'dev' -o -fstype 'proc' \\) -prune \
                      -o -type d -print 2> /dev/null | sed 1d | cut -b3-"}"
                    cd "${$(eval "$cmd" | $(__fzfcmd) +m):-.}" && pwd
                    zle reset-prompt
                  }
                  zle     -N    fzf-cd-widget
                  bindkey '^G' fzf-cd-widget

                  # CTRL-r - Paste the selected command from history into the command line
                  fzf-history-widget() {
                    local selected num
                    selected=( $(fc -l 1 | $(__fzfcmd) +s --tac +m -n2..,.. --tiebreak=index --toggle-sort=ctrl-r -q "${LBUFFER//$/\\$}") )
                    if [ -n "$selected" ]; then
                      num=$selected[1]
                      if [ -n "$num" ]; then
                        zle vi-fetch-history -n $num
                      fi
                    fi
                    zle redisplay
                  }
                  zle     -N   fzf-history-widget
                  bindkey '^R' fzf-history-widget
              fi
          # }

          # magic enter = ls && git status {
              do_enter () {
                  if [ -n "$BUFFER" ]; then
                      zle accept-line
                      return 0
                  fi
                  echo
                  ls
                  if [ "$(git rev-parse --is-inside-work-tree 2> /dev/null)" = 'true' ]; then
                      echo
                      echo -e "\e[0;33m--- git status ---\e[0m"
                      git status -sb
                  fi
                  zle reset-prompt
                  return 0
              }
              zle -N do_enter
              bindkey '^m' do_enter
          # }

          # rational dots {
              # type '...' to get '../..' with successive .'s adding /..
              function rationalise_dot {
                  local MATCH # keep the regex match from leaking to the environment
                  if [[ $LBUFFER =~ '(^|/| |      |'$'\n''|\||;|&)\.\.$' ]]; then
                    LBUFFER+=/
                    zle self-insert
                    zle self-insert
                  else
                    zle self-insert
                  fi
              }
              zle -N rationalise_dot
              bindkey . rationalise_dot
              # without this, typing a . aborts incremental history search
              bindkey -M isearch . self-insert
          # }
      # }

      bindkey -e
      export WORDCHARS=''                                 # do not jump over whole POSIX path
      bindkey '^N' accept-and-hold                        # ctrl n .................... multiselect in menu complete
      bindkey '^[^[[D' backward-word                      # alt <arrow-left>............move a word backward
      bindkey '^[^[[C' forward-word                       # alt <arrow-right>...........move a word forward
      bindkey '^[^H' backward-kill-word                   # cmd <del>...................delete the word left of the cursor
      bindkey '^A' beginning-of-line                      # cmd <arrow-left>............move to the beginning of the line
      bindkey '^E' end-of-line                            # cmd <arrow-right>...........move to the end of the line
      bindkey '^[^[[B' kill-whole-line                    # cmd <arrow-down>............delete the whole line
      bindkey '^X' delete-char                            # ctrl x......................delete the char under the cursor
      bindkey '^W' delete-word                            # ctrl w......................delete the word under the cursor
      bindkey -s '^[^[[A' 'cd ..\n'                       # alt <arrow-up>..............cd ..
      bindkey -s '^L' 'ls -laH\n'                         # ctr l.......................ls -laH
      bindkey '^[[A' history-beginning-search-backward    # <arrow-up>..................history substring search backward
      bindkey '^[[B' history-beginning-search-forward     # <arrow-down>................history substring search forward
  # }}}



  test -e "${HOME}/.iterm2_shell_integration.zsh" && source "${HOME}/.iterm2_shell_integration.zsh"
  


cdf () {  # short for cdfinder
  cd "`osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)'`"
}
# Copy w/ progress
cp_p () {
  rsync -WavP --human-readable --progress $1 $2
}

# who is using the laptop's iSight camera?
camerausedby () {
  echo "Checking to see who is using the iSight camera‚Ä¶ üì∑"
  usedby=$(lsof | grep -w "AppleCamera\|USBVDC\|iSight" | awk '{printf $2"\n"}' | xargs ps)
  echo -e "Recent camera uses:\n$usedby"
}

# animated gifs from any video
# from Alex Sexton gist.github.com/SlexAxton/4989674
gifify () {
  if [[ -n "$1" ]]; then
  if [[ $2 == '--good' ]]; then
    ffmpeg -i "$1" -r 10 -vcodec png out-static-%05d.png
    time convert -verbose +dither -layers Optimize -resize 900x900\> out-static*.png  GIF:- | gifsicle --colors 128 --delay=5 --loop --optimize=3 --multifile - > "$1.gif"
    rm out-static*.png
  else
    ffmpeg -i "$1" -s 600x400 -pix_fmt rgb24 -r 10 -f gif - | gifsicle --optimize=3 --delay=3 > "$1.gif"
  fi
  else
  echo "proper usage: gifify <input_movie.mov>. You DO need to include extension."
  fi
}

# turn that video into webm.
# brew reinstall ffmpeg --with-libvpx
webmify () {
  ffmpeg -i "$1" -vcodec libvpx -acodec libvorbis -isync -copyts -aq 80 -threads 3 -qmax 30 -y "$2" "$1.webm"
}
# Get week number
alias week='date +%V'

# Get macOS Software Updates, and update installed Ruby gems, Homebrew, npm, and their installed packages
alias update='sudo softwareupdate -i -a; brew update; brew upgrade; brew cleanup; npm install npm -g; npm update -g; sudo gem update --system; sudo gem update; sudo gem cleanup'

alias ip="dig +short myip.opendns.com @resolver1.opendns.com"
alias localip="ipconfig getifaddr en0"
alias ips="ifconfig -a | grep -o 'inet6\? \(addr:\)\?\s\?\(\(\([0-9]\+\.\)\{3\}[0-9]\+\)\|[a-fA-F0-9:]\+\)' | awk '{ sub(/inet6? (addr:)? ?/, \"\"); print }'"

# JavaScriptCore REPL

jscbin="/System/Library/Frameworks/JavaScriptCore.framework/Versions/A/Resources/jsc";
[ -e "${jscbin}" ] && alias jsc="${jscbin}";
unset jscbin;

# Trim new lines and copy to clipboard
alias c="tr -d '\n' | pbcopy"

# Hide/show all desktop icons (useful when presenting)
alias hidedesktop="defaults write com.apple.finder CreateDesktop -bool false && killall Finder"
alias showdesktop="defaults write com.apple.finder CreateDesktop -bool true && killall Finder"


# URL-encode strings
alias urlencode='python -c "import sys, urllib as ul; print ul.quote_plus(sys.argv[1]);"'
# Merge PDF files
# Usage: `mergepdf -o output.pdf input{1,2,3}.pdf`
alias mergepdf='/System/Library/Automator/Combine\ PDF\ Pages.action/Contents/Resources/join.py'

# Intuitive map function
# For example, to list all directories that contain a certain file:
# find . -name .gitattributes | map dirname
alias map="xargs -n1"

# One of @janmoesen‚Äôs ProTip‚Ñ¢s
for method in GET HEAD POST PUT DELETE TRACE OPTIONS; do
	alias "${method}"="lwp-request -m '${method}'"
done

# Stuff I never really use but cannot delete either because of http://xkcd.com/530/
alias stfu="osascript -e 'set volume output muted true'"
alias pumpitup="osascript -e 'set volume output volume 100'"

# Lock the screen (when going AFK)
alias afk="/System/Library/CoreServices/Menu\ Extras/User.menu/Contents/Resources/CGSession -suspend"

# Reload the shell (i.e. invoke as a login shell)
alias reload="exec ${SHELL} -l"

# Print each PATH entry on a separate line
alias path='echo -e ${PATH//:/\\n}'

# Syntax-highlight JSON strings or files
# Usage: `json '{"foo":42}'` or `echo '{"foo":42}' | json`
function json() {
	if [ -t 0 ]; then # argument
		python -mjson.tool <<< "$*" | pygmentize -l javascript;
	else # pipe
		python -mjson.tool | pygmentize -l javascript;
	fi;
}

  eg(){
  # https://news.ycombinator.com/item?id=10797303
      MAN_KEEP_FORMATTING=1 man "$@" 2>/dev/null \
          | sed --quiet --expression='/^E\(\x08.\)X\(\x08.\)\?A\(\x08.\)\?M\(\x08.\)\?P\(\x08.\)\?L\(\x08.\)\?E/{:a;p;n;/^[^ ]/q;ba}' \
          | ${MANPAGER:-${PAGER:-pager -s}}
  }

#+END_SRC
