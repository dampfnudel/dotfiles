# -*- mode: Org; eval: (auto-composition-mode 0) -*- #

#+AUTHOR: Markus Bayer
#+DATE: [2017-11-17 Fr]
#+BABEL: cache no
#+PROPERTY: header-args shell :tangle zsh.zsh

#          ▄███████▄     ▄████████    ▄█    █▄       ▄████████  ▄████████
#          ▀█▀▄███▀▄▄   ███         ▄███▄▄▄▄███▄▄  ▄███▄▄▄▄██▀ ███
#           ▄███▀   ▀ ▀███████████ ▀▀███▀▀▀▀███▀  ▀▀███▀▀▀▀▀   ███
#         ▄███▀                ███   ███    ███   ▀███████████ ███    █▄
# ████    ███▄     ▄█    ▄█    ███   ███    ███     ███    ███ ███    ███
# ████     ▀████████▀  ▄████████▀    ███    █▀      ███    ███ ████████
#                                                   ███    ███

# ASCII-Art credits: http://patorjk.com/software/taag/#p=display&f=Delta%20Corps%20Priest%201&t=.zshrc
* INDEX
[[#INDEX]]
[[#setup]]
[[#environment]]
[[#completions]]
[[#aliases]]
[[#functions]]
[[#keybindings]]
[[#plugins]]
[[#original-zshrc]]

* Setup
:PROPERTIES:
:CUSTOM_ID: setup
:END:
** org-tangle
#+BEGIN_SRC shell
tangle () {
    FILE=$(realpath $1)
    open -a /usr/local/Cellar/emacs/25.2/Emacs.app --args --eval "(progn
        (require 'org)
        (find-file (expand-file-name \"$FILE\"))
        (org-babel-tangle))"
}
#+END_SRC

** symlink
#+BEGIN_SRC shell
old () {
    rm ~/.zshrc
    ln -s ~dotfiles/zshrc.zsh ~/.zshrc
}

new () {
    rm ~/.zshrc
    ln -s ~dotfiles/zsh.zsh ~/.zshrc
}
#+END_SRC

* Environment
:PROPERTIES:
:CUSTOM_ID: environment
:END:

** iterm2 shell integration                                         :plugin:
#+BEGIN_SRC shell
  # https://www.iterm2.com/documentation-shell-integration.html
  # source ~dotfiles/zsh/iterm2_shell_integration/iterm2_shell_integration.zsh
#+END_SRC

** ZSH Options
http://zsh.sourceforge.net/Doc/Release/Options.html

unsetopt option == setopt no_option
#+BEGIN_SRC shell
# allow to change to a directory by entering it as a command
setopt auto_cd
# prevent > redirection from truncating the given file if it already exists
setopt no_clobber
# recognize comments
setopt interactivecomments

## correction
# automatically correct the spelling of each word on the command line
setopt correct_all
# try to correct the spelling of commands.
setopt correct

## history
# zsh sessions will append their history list to the history file, rather than replace it. Thus, multiple parallel zsh sessions will all have the new entries from their history lists added to the history file
setopt append_history
# works like APPEND_HISTORY except that new history lines are added to the $HISTFILE incrementally (as soon as they are entered), rather than waiting until the shell exits
setopt inc_append_history
# save each command’s beginning timestamp (in seconds since the epoch) and the duration (in seconds) to the history file
setopt extended_history
# the oldest history event that has a duplicate will be lost before losing a unique event from the list
setopt hist_expire_dups_first
# ignore duplication command history list
setopt hist_ignore_dups
# remove command lines from the history list when the first character on the line is a space
setopt hist_ignore_space
# whenever the user enters a line with history expansion, don’t execute the line directly; instead, perform history expansion and reload the line into the editing buffer.
setopt hist_verify
# use the same history file for all sessions
setopt share_history

## completion
# do not autoselect the first completion entry
unsetopt menu_complete
# show completion menu on successive tab press
setopt auto_menu
# if unset, the cursor is set to the end of the word if completion is started. Otherwise it stays there and completion is done from both ends.
setopt complete_in_word
# if a completion is performed with the cursor within a word, and a full completion is inserted, the cursor is moved to the end of the word. That is, the cursor is moved to the end of the word if either a single match is inserted or menu completion is performed.
setopt always_to_end
#+END_SRC

** Hashes
#+BEGIN_SRC shell
export HOME=/Users/mbayer
# projects
hash -d ai=$HOME/Workspace/ai
hash -d amber=$HOME/Workspace/amber
hash -d bay=$HOME/Workspace/bay
hash -d gists=$HOME/Workspace/gists
hash -d hackedHN=$HOME/Workspace/hackedHN
hash -d impure=$HOME/Workspace/impure
# system
hash -d bin=$HOME/bin
hash -d desktop=$HOME/Desktop
hash -d dev=$HOME/Workspace
hash -d documents=$HOME/Documents
hash -d dotfiles=$HOME/Settings/dotfiles
hash -d downloads=$HOME/Downloads
hash -d dropbox=$HOME/Dropbox
hash -d emacs.d=$HOME/.emacs.d
hash -d library=$HOME/Library
hash -d music=$HOME/Music
hash -d oh-my-zsh=$HOME/.oh-my-zsh
hash -d org=$HOME/Documents/org
hash -d pictures=$HOME/Pictures
hash -d screenshots=~pictures/Screenshots
hash -d regiobot=$HOME/Workspace/project-inquant/gitlab
hash -d rezepte=$HOME/Documents/org/rezepte
hash -d scripts=$HOME/Workspace/scripts
hash -d settings=$HOME/Settings
hash -d tmp=$HOME/tmp
hash -d trash=$HOME/.Trash
hash -d utils=$HOME/utils
hash -d videos=$HOME/Movies
# mounts
hash -d i32=/Volumes/INGOT32
hash -d i64=/Volumes/INGOT64
hash -d sd2=/Volumes/sd2
hash -d sd=/Volumes/sd
hash -d v=/Volumes
# mobile
hash -d mobile_audiobooks=root@192.168.178.41:/storage/extSdCard/Audiobooks
hash -d mobile_images=root@192.168.178.41:/storage/extSdCard/DCIM
hash -d mobile_org=root@192.168.178.41:/storage/sdcard0/org_m
hash -d mobile_sd=root@192.168.178.41:/storage/extSDCard
hash -d mobile_storage=root@192.168.178.41:/storage/sdcard0
# files
hash -d emacsrc=$HOME/Settings/dotfiles/emacsrc.org
hash -d vimrc=$HOME/Settings/dotfiles/vimrc.vim
hash -d zsh_history=$HOME/.zsh_history
hash -d zshrc=$HOME/Settings/dotfiles/zshrc.zsh
#+END_SRC

** ZSH Parameters
#+BEGIN_SRC shell
# $PATH
export PATH="/usr/local/bin:/usr/local/sbin:/usr/bin:/bin:/usr/sbin:/sbin:$HOME/bin:$PATH"

# paths
# TODO hash?
export BIN=/usr/local/bin
export DOTFILES="$HOME/Settings/dotfiles"

# language
export LANG=de_DE.UTF-8
export LC_ALL=de_DE.UTF-8

# history
# TODO rm 2
export HISTFILE="$HOME/.zsh_history2"
export HISTSIZE=1200000
export SAVEHIST=1000000

# $EDITOR
if [[ -n $SSH_CONNECTION ]]; then
    export EDITOR="$BIN/vim"
else
    export EDITOR=~scripts/emacs.sh
    # TODO rm obsolete
    export EDITOR_TAB=${EDITOR}
    export VIM_EDITOR="$BIN/mvim"
    # TODO function || alias
    export VIM_EDITOR_TAB="${VIM_EDITOR} --remote-tab-silent"
fi

# A list of non-alphanumeric characters considered part of a word by the line editor.
export WORDCHARS='*?_-.[]~=/&;!#$%^(){}<>/'

# $LS_COLORS
# TODO
eval $(gdircolors -b "$DOTFILES/themes/dircolors/zenburn.256dark")
# used by k
# export LSCOLORS='di=36:ln=35:so=32:pi=33:ex=31:bd=34;46:cd=34;43:su=30;41:sg=30;46:tw=30;42:ow=30;43'
export LSCOLORS='exfxcxdxbxegedabagacad'

#+END_SRC

** Python Parameters
#+BEGIN_SRC shell
# project amber
export DJANGO_SETTINGS_MODULE=amber.settings
#+END_SRC

** Other Parameters
*** encryption
#+BEGIN_SRC shell
# PGP
GPG_TTY=$(tty)
export GPG_TTY
#+END_SRC

** command variables

* Completions
:PROPERTIES:
:CUSTOM_ID: completions
:END:
http://zsh.sourceforge.net/Doc/Release/Roadmap.html#Completion-1
http://zsh.sourceforge.net/Doc/Release/Options.html#Completion-2
http://www.masterzen.fr/2009/04/19/in-love-with-zsh-part-one/
https://unix.stackexchange.com/questions/185537/combining-zsh-s-tab-completion-with-case-insensitivity
#+BEGIN_SRC shell
# initialize the completion system
autoload -U compinit && compinit
# enable menu widget
# zstyle ':completion*:default' menu 'select=1'
zstyle ':completion:*' menu select
# use dircolors in completion listings
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}
# color options red, descriptions green
zstyle ':completion:*:options' list-colors '=(#b)*(-- *)=31=32'
zstyle ':completion:*:common-commands' list-colors '=(#b)*(-- *)=31=32'
# print the completion type
zstyle ':completion:*' verbose yes
zstyle ':completion:*' format 'Completing %B%d%b'
# TODO style
zstyle ':completion:*:descriptions' format "$fg[yellow]%B--- %d%b"
zstyle ':completion:*:messages' format '%d'
zstyle ':completion:*:warnings' format "$fg[red]No matches for:$reset_color %d"
zstyle ':completion:*:corrections' format '%B%d (errors: %e)%b'
# group different completion types
zstyle ':completion:*' group-name ''
# error can be a transposed character, a missing character or an additional character
# to have a better heuristic, by allowing one error per 6 character typed
zstyle ':completion:*:approximate:*' max-errors 'reply=( $(( ($#PREFIX+$#SUFFIX)/6 )) numeric )'
# case insensitive matching
zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}' 'r:|=*' 'l:|=* r:|=*'
# caching
zstyle ':completion:*' use-cache on
# TODO required?
zstyle ':completion:*' cache-path "$HOME/.zsh/cache"
# ignore completion functions for commands you don’t have:
zstyle ':completion:*:functions' ignored-patterns '_*'
# don't complete uninteresting users
zstyle ':completion:*:*:*:users' ignored-patterns \
    adm amanda apache at avahi avahi-autoipd beaglidx bin cacti canna \
    clamav daemon dbus distcache dnsmasq dovecot fax ftp games gdm \
    gkrellmd gopher hacluster haldaemon halt hsqldb ident junkbust kdm \
    ldap lp mail mailman mailnull man messagebus  mldonkey mysql nagios \
    named netdump news nfsnobody nobody nscd ntp nut nx obsrun openvpn \
    operator pcap polkitd postfix postgres privoxy pulse pvm quagga radvd \
    rpc rpcuser rpm rtkit scard shutdown squid sshd statd svn sync tftp \
    usbmux uucp vcsa wwwrun xfs '_*'
# don't complete uninteresting files
zstyle ':completion:*:emacs:*' ignored-patterns '*.(o|a|so|aux|dvi|swp|fig|bbl|blg|bst|idx|ind|out|toc|class|pdf|ps|pyc)'
# avoid getting offered the same filename with rm
zstyle ':completion:*:rm:*' ignore-line yes
#+END_SRC

** Python

      path=(
          $path
          /usr/bin/python
          /usr/local/bin/python3
      )

      # virtualenv {
          export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python
          export PROJECT_HOME=$HOME/Workspace
          export WORKON_HOME=$HOME/Workspace/Envs
          export VIRTUALENV_ROOT=$WORKON_HOME
          export DEFAULT_PYTHON_INTERPRETER=$WORKON_HOME/python3.4.1/bin/python
          source /usr/local/bin/virtualenvwrapper.sh

          # fix the new tab = virtual_env dir bug
          if [[ "$PWD" == "$HOME/Workspace/Envs" ]]; then
              cd - > /dev/null
          fi

*** virtualenvwrapper                                              :plugin:
https://virtualenvwrapper.readthedocs.io/en/latest/
#+BEGIN_SRC shell
export WORKON_HOME=~dev/Envs
export PROJECT_HOME=~dev
source "$BIN/virtualenvwrapper.sh"
#+END_SRC

*** virtualenv                                                     :plugin:
https://virtualenv.pypa.io/en/latest/
#+BEGIN_SRC shell
# set default virtual_env
export VIRTUALENV_DEFAULT_PATH="$WORKON_HOME/python3.4.1/bin/activate"
# load it
if [[ $(basename "$VIRTUAL_ENV") == "" ]]
then
    if [[ -f "$VIRTUALENV_DEFAULT_PATH" ]]; then
        source "$VIRTUALENV_DEFAULT_PATH"
    fi
fi
#+END_SRC

* Aliases
:PROPERTIES:
:CUSTOM_ID: aliases
:END:

#+BEGIN_SRC shell
# TODO section for overriding
## list
# use gnu ls for dircolors
alias ls='gls --color=auto'
# list details
alias ll='ls -lah'
# sort by size
alias lss='ls -lahS'
# sort by date
alias lsd='ls -latr'
# only today
alias lst='find . -maxdepth 1 -type f -mtime 1'
# numFiles: number of (non-hidden) files in current directory
alias lsc='echo $(ls -1 | wc -l)'
alias k='k -h'     # human readable sizes
# disk usage statistics default
alias du="du -ach | sort"
# free diskspace with human readable size
alias df='df -h'
# stat with human readable times
alias stat='stat -x'

## tools
# emacs
alias e="eval $EDITOR"
# vim
alias cvim='/usr/local/bin/vim'
# create parent directories on demand
alias mkdir="mkdir -pv"
# clipboard
alias p='pbpaste'
alias y='pbcopy'
alias bpython='$WORKON_HOME/python3.4.1/bin/bpython'
alias grep='grep --color'
## internet
# continue the download in case of problems
alias wget="wget -c"
alias chrome='/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome'
alias chrome_headless='/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --headless --disable-gpu'
alias yt3='$WORKON_HOME/python3.4.1/bin/youtube-dl --verbose --extract-audio --audio-format mp3 --no-mtime --no-cache-dir'
alias yt='$WORKON_HOME/python3.4.1/bin/youtube-dl --no-mtime --no-cache-dir'
# weather
alias wttr='curl -s http://wttr.in | tail +8 | head -30'
# moonphase
alias moon='curl -s wttr.in/Moon|head -25'

# git
alias gs='git status'
alias gpl='git pull'
alias gps='git push'
alias gl='git log'
alias gco='git checkout'

alias git_push_fire='git add -A && git commit -a --allow-empty-message -m "" && git push'
alias git_undo_commit='git reset --soft HEAD~'

## actions
alias s='source ~zshrc'
# TODO as functions
# TODO internal/external
alias print_ip='ifconfig | grep "inet " | grep -v 127.0.0.1 | cut -d\  -f2'
# substitute windows linebreak with unix linebreak
alias fix_linebreaks="/usr/bin/perl -i -pe's/\r$//'"
alias pip_update_all="pip freeze --local | grep -v '^\-e' | cut -d = -f 1  | xargs -n1 pip install -U"

alias osx_show_hidden='defaults write com.apple.Finder AppleShowAllFiles YES && killall Finder'
alias osx_hide_hidden='defaults write com.apple.Finder AppleShowAllFiles NO && killall Finder'
alias osx_empty_trash="rm -rf ~/.Trash/."
alias fix_carriage_return="tr '\r' '\n' <"

## cleanup
# TODO as functions
# rm_DS_Store_files: removes all .DS_Store file from the current dir and below
alias rm_ds_store='find . -name .DS_Store -exec rm {} \;'
alias rm_pyc_files='find . -name "*.pyc" -exec rm {} \;'
alias rm_svn_files='find . -type d -name .svn -exec rm -rf {} \;'
alias rm_emacs_files="find . -maxdepth 1 -type f -name '#*#' -exec rm {}\;"
#+END_SRC

** Global aliases
#+BEGIN_SRC shell
## redirection
# redirect stdout, stderr
alias -g _no_output='> /dev/null 2>&1'
# redirect stderr
alias -g _no_stderr='2> /dev/null'
# redirect stdout
alias -g _no_stdout='&> /dev/null'

## tools
alias -g _vim="| eval ${EDITOR_TAB}"
alias -g _y='| pbcopy'

## files
# alias -g PASS='<(ypcat passwd)'
alias -g _brew='<(brew list)'
alias -g _pip='<(pip freeze)'
alias -g _gem='<(gem list | tail -n +1)'
#  ¯\_(ツ)_/¯
alias -g _npm="<(npm list -g --depth=0 2> /dev/null |cut -c5- | tail -n +2 | sed \$d)"
# TODO function wrapper
alias -g _shrugf='<(echo "¯\\_(ツ)_/¯")'

## variables
alias -g _shrugv='${$(echo "¯\\_(ツ)_/¯")}'

## filter
# filter columns
alias -g _awk1="|awk '{print \$1}'"
alias -g _awk2="|awk '{print \$2}'"
alias -g _awk3="|awk '{print \$3}'"
alias -g _awk4="|awk '{print \$4}'"
alias -g _awk5="|awk '{print \$5}'"
alias -g _awk6="|awk '{print \$6}'"
# filter with fzf
alias -g _f="|fzf"
# pager
alias -g _l="|less"
# count lines
alias -g _cl='|wc -l'
alias -g _lc='_cl'
# archives in pwd
alias -g _acd='./(*.bz2|*.gz|*.tgz|*.zip|*.z)'
## map
# funky
alias -g _x='| xargs'
alias -g map='_x'
#+END_SRC

** Suffix aliases
#+BEGIN_SRC shell
# TODO
# open org-mode files in emacs
alias -s org=emacs
# TODO Glob
alias -s jpg=imgcat
alias -s png=imgcat
#+END_SRC

* Functions
:PROPERTIES:
:CUSTOM_ID: functions
:END:
# TODO echo $nameddirs|tr " " "\n"|fzf

** Helper functions
#+BEGIN_SRC shell
# called on every cd
chpwd () {
    # put the current directory in the title/tab bar
    # -P option treat its arguments like a prompt string; otherwise the %~ would not be expanded. -n suppresses the terminating newline
    print -Pn "\e]1;%~\a"
}

function __expect () {
    # check if the expected arg amount $1 matches the passed arg amount $2
    # usage:
    # __expect 1 "$#" || return 1
    # TODO get args implicit from last command
    local params_expected params_given
    arguments_expected="$1"
    arguments_given="$2"
    if [[ "$arguments_expected" == "$arguments_given" ]]
    then
        return 0
    # TODO handle
    elif [[ "$arguments_expected" < "$arguments_given" ]]
    then
        return 0
    else
        echo "$arguments_expected arguments required"
        return 1
    fi
}
test () {
__expect 2
}
#+END_SRC

** functions with keybindings
#+BEGIN_SRC shell
# TODO rm
# example fzf completion https://github.com/junegunn/fzf/wiki/Examples-(completion)
# Custom fuzzy completion for "doge" command
#   e.g. doge **<TAB>
_fzf_complete_doge() {
  _fzf_complete "--multi --reverse" "$@" < <(
    echo very
    echo wow
    echo such
    echo doge
  )
}

# tab completion for the output of the previous command {
_prev_result () {
    local hstring
    hstring=$(eval `fc -l -n -1`)
    set -A hlist ${(@s/
/)hstring}
    compadd - ${hlist}
}

zle -C prev-comp menu-complete _prev_result
# usage
# $ find . -name "settings.py.*"
# $ vim <Escape>e<Tab>
bindkey '\ee' prev-comp
# }

# fzf filter for the output of the previous command {
fzf_filter_prev () {
    local selection
    selection=$(fc -e - | fzf)
    if [[ -a $selection ]]
    then
        smart_open $selection
    fi
}

zle -N fzf_filter_prev
# usage
# $ ls
# $ <Escape>f
bindkey -s '\ef' 'fzf_filter_prev\n'
# }

# open last output {
open_prev () {
    local files
    files=$(fc -e -)
    if [[ -a $files ]]
    then
        smart_open $files
    fi
}

zle -N open_prev
# usage
# $ ls
# $ <Escape>o
bindkey -s '\eo' 'open_prev\n'
# }

# copy the output of the previous command to clipboard {
copy_prev () {
    fc -e - | pbcopy
}

zle -N cp_prev
# usage
# $ ls
# $ <Escape>c
bindkey -s '\ec' 'cp_prev\n'
# }

# tab completion for git status files {
_git_status_files () {
    local files
    files=$(git status --porcelain | awk '{print $2 }')
    # sleep?
    sleep 1
    set -A flist ${(@s/
/)files}
    compadd - ${flist}
}

zle -C git-files menu-complete _git_status_files
# usage
# $ git add <Escape>g<Tab>
bindkey '\eg' git-files
# }

#+END_SRC

** OS
#+BEGIN_SRC shell
function get_shell_integration () {
    # https://www.iterm2.com/documentation-shell-integration.html
    curl -L https://iterm2.com/shell_integration/zsh \
    -o ~dotfiles/zsh/iterm2_shell_integration/iterm2_shell_integration.zsh
}
#+END_SRC
*** iterm2
#+BEGIN_SRC shell
function iterm_rename_tab () {
    echo -ne "\033]0;"$@"\007"
}

function iterm_set_tabcolor {
    case $1 in
        green)
        echo -e "\033]6;1;bg;red;brightness;57\a"
        echo -e "\033]6;1;bg;green;brightness;197\a"
        echo -e "\033]6;1;bg;blue;brightness;77\a"
        ;;
    red)
        echo -e "\033]6;1;bg;red;brightness;270\a"
        echo -e "\033]6;1;bg;green;brightness;60\a"
        echo -e "\033]6;1;bg;blue;brightness;83\a"
        ;;
    orange)
        echo -e "\033]6;1;bg;red;brightness;227\a"
        echo -e "\033]6;1;bg;green;brightness;143\a"
        echo -e "\033]6;1;bg;blue;brightness;10\a"
        ;;
    esac
}
#+END_SRC
hello there

** packages
*** homebrew
#+BEGIN_SRC shell
function bip() {
    # Install (one or multiple) selected application(s)
    # using "brew search" as source input
    # mnemonic [B]rew [I]nstall [P]lugin
    local inst=$(brew search | fzf -m)

    if [[ $inst ]]; then
      for prog in $(echo $inst);
      do; brew install $prog; done;
    fi
}

function bup() {
    # Update (one or multiple) selected application(s)
    # mnemonic [B]rew [U]pdate [P]lugin
    local upd=$(brew leaves | fzf -m)

    if [[ $upd ]]; then
      for prog in $(echo $upd);
      do; brew upgrade $prog; done;
    fi
}
function bcp() {
    # Delete (one or multiple) selected application(s)
    # mnemonic [B]rew [C]lean [P]lugin (e.g. uninstall)
    local uninst=$(brew leaves | fzf -m)

    if [[ $uninst ]]; then
    for prog in $(echo $uninst);
    do; brew uninstall $prog; done;
    fi
}
#+END_SRC

** Internet
#+BEGIN_SRC shell
function chrome_history () {
    # browse chrome history
    local cols sep entry
    cols=$(( COLUMNS / 3 ))
    sep='{{::}}'

    # Copy History DB to circumvent the lock
    # - See http://stackoverflow.com/questions/8936878 for the file path
    cp -f ~/Library/Application\ Support/Google/Chrome/Default/History /tmp/h

    entry=$(sqlite3 -separator $sep /tmp/h \
        "select substr(title, 1, $cols), url
        from urls order by last_visit_time desc" |
    awk -F $sep '{printf "%-'$cols's  \x1b[36m%s\n", $1, $2}' |
    fzf --ansi --multi | sed 's#.*\(https*://\)#\1#')
    echo "$entry"
    open "$entry"
}

function chrome_print_tabs () {
    # list the opened tabs in google chrome
    osascript -e 'set text item delimiters to linefeed' -e'tell app "google chrome" to url of tabs of window 1 as text' | tail -n +1

}

function cat_links () {
    # extract the links from a given url
    __expect 1 "$#" || return 1
    curl "$@" | sed -n 's/.*href="\([^"]*\).*/\1/p'
}

function print_external_ip () {
    # print the external ip
    curl ipecho.net/plain
}
#+END_SRC

** Clipboard
#+BEGIN_SRC shell
clipboard_plain_text () {
    # convert clipboard content to plain text
    pbpaste | textutil -convert txt -stdin -stdout -encoding 30 | pbcopy
}

function clipboard_rm_python () {
    # rm ">>> " "from clipboard entry
    pbpaste | cut -c 4- | pbcopy
}
#+END_SRC

** cd
#+BEGIN_SRC shell
function fdr() {
    # TODO fcd & fcd_up
    # fdr - cd to selected parent directory
    local declare dirs=()
    get_parent_dirs() {
      if [[ -d "${1}" ]]; then dirs+=("$1"); else return; fi
      if [[ "${1}" == '/' ]]; then
        for _dir in "${dirs[@]}"; do echo $_dir; done
      else
        get_parent_dirs $(dirname "$1")
      fi
    }
    local DIR=$(get_parent_dirs $(realpath "${1:-$PWD}") | fzf-tmux --tac)
    cd "$DIR"
}
#+END_SRC

** Print / echo

#+BEGIN_SRC shell
function cat_human_time () {
    # print unix timestamps in human readable form
    __expect 1 "$#" || return 1
    perl -lne 'm#: (\d+):\d+;(.+)# && printf "%s :: %s\n",scalar localtime $1,$2' "$1"
}

function tac () {
    # reverse line order of file
    __expect 1 "$#" || return 1
    sed '1!G;h;$!d' "$@"
}

function print_timestamp () {
    echo $(date +%Y-%m-%d-%H-%M-%S)
}

function print_datestamp () {
    echo $(date +%Y-%m-%d)
}

#+END_SRC

** List
TODO wrapper function for single & multiple files
#+BEGIN_SRC shell
# TODO fzf
function li () {
    # print the latest file or dir in $1
    local idx dir
    # no params: dir=pwd
    if [ $# -eq 0 ]; then dir="$(pwd)"; else dir="$1" fi
    # no index: index=last
    if [ -z "$2" ]; then idx="1"; else idx="$2"; fi
    (cd "$dir" && realpath "$(ls -1t | head -n$idx | tail -1)")
}

function gru () {
    # print the git remote url
    git config --get remote.origin.url
}

function gbn () {
    # print the git branch name
    git branch|grep "\*"|awk '{print $2}'
}

lscat () {
    # print a separated list of files in dir $1
    local dir
    if [ $# -eq 0 ]; then dir="$(pwd)"; else dir="$1" fi
    find "$dir" -maxdepth 1 -type f -print | while read -r d
    do
        echo ""
        echo "=-=-= $d =-=-="
        echo "------------------------------------------------"
        echo ""
        pygmentize "$d" || cat "$d"
        echo ""
    done
}

count_files () {
    # count files in dir $1
    local dir
    if [ $# -eq 0 ]; then dir="$(pwd)"; else dir="$1" fi
    for d in $(find "$dir" -type d -print);
    do
        files=$(find "$d" -maxdepth 1 -type f | wc -l )
        echo "$d : $files"
    done
}
function list_all_apps () {
    # list all applications on the system
    mdfind 'kMDItemContentTypeTree == "com.apple.application"c'
}
#+END_SRC

** File

** Modify
#+BEGIN_SRC shell
function kill_lines_containing () {
    # delete lines containing pattern $1 in file $2
    if [ $# -lt 2 ]; then echo "Usage: kill_lines_containing <PATTERN> <FILE>"; return 1; fi
    sed -i '' "/$1/d" "$2"
}

#+END_SRC

** Find
http://www.macdevcenter.com/pub/a/mac/2006/01/04/mdfind.html?page=4
http://developer.apple.com/documentation/Carbon/Conceptual/SpotlightQuery/index.html

#+BEGIN_SRC shell
function ff () {
    # find a file under the current directory
    # rg --files --hidden --follow -g "$@"
    find . -name "$@"
}

function fff () {
    # fuzzy find file under the current directory
    find . -name "*$@*"
}

function ffs () {
    # find a file whose name starts with a given string
    find . -name "$@"'*'
}

function ffe () {
    # find a file whose name ends with a given string
    find . -name '*'"$@"
}

function fd () {
    # find a directory
    find . -type d -name '*'"$@"
}

function ffd () {
    # fuzzy find a directory
    find . -type d -name "*$@*"
}

# git repo
function ffg () {
    # find a file under the current git repo
    find $(git rev-parse --show-toplevel) -name "$@"
}

function ffsg () {
    # find a file whose name starts with a given string within the current git repo
    find $(git rev-parse --show-toplevel) -name "$@"'*'
}

function ffeg () {
    # find a file whose name ends with a given string within the current git repo
    find $(git rev-parse --show-toplevel) -name '*'"$@"
}

function fdg () {
    # find a directory within the current git repo
    find $(git rev-parse --show-toplevel) -type d -name '*'"$@"
}

function rgg () {
    # rg within the git dir
    /usr/local/bin/ag "$@" $(git rev-parse --show-toplevel)
}

## Spotlight
function fs () {
    # find file using Spotlight
    mdfind "kMDItemDisplayName == '$@'wc"
}

function fs_type () {
    # find file by filetype using Spotlight
    # ex: ft video || ft bild || ft pdf
    # c means case insensitive
    mdfind 'kMDItemKind == "*'"$1"'*"c'
}

function fs_recent() {
    # find files created since $1 days using Spotlight
    mdfind -onlyin ~ '(kMDItemContentCreationDate > "$time.today(-'"$1"')") (kMDItemContentCreationDate < ")'
}

function f_word () {
    # lookup words
    grep ^"$@"$ /usr/share/dict/words
}

f_larger () {
    # find files larger than a certain size (in bytes)
    find . -type f -size +${1}c
}
#+END_SRC

** Select / filter
#+BEGIN_SRC shell
function fli () {
    # (fzf-)filter file in a given directory (sorted by dates)
    __expect 1 "$#" || return 1
    (cd "$1" && realpath "$(ls -1t | fzf)")
}
#+END_SRC

** Directory
** Operations / actions                                             :plugin:
#+BEGIN_SRC shell
  function append_above () {
      __expect 1 "$#" || return 1
      # like >> but on top instead of below
      # ex: chrome_print_tabs | append_above somefile
      cat - "$1" | sponge "$1"
  }
#+END_SRC

** old
#+BEGIN_SRC shell
fcd () {
    # fzf cd - cd to selected directory
    local dir
    dir=$(find ${1:-*} -path '/*/\.*' -prune \
        -o -type d -print 2> /dev/null | fzf) &&
        realpath "$dir"
    cd "$dir"
}

rg_fzf () {
    # search for file contents; select with fzf
    rg --files-with-matches "$@" | fzf
}

pjson () {
    # pretty print json
    # ex:
    # pjson '{"test": "test"}'
    # pjson myjsonfile.json
    # pjson '{"test": "test"}' myjsonfile.json
    if [ $# -gt 0 ];
    then
        for arg in $@
        do
            if [ -f $arg ];
            then
                less $arg | python -m json.tool
            else
                echo "$arg" | python -m json.tool
            fi
        done
    fi
}

vim () {
    if [ $# -eq 0 ]; then
        # open -a Emacs.app
        eval ${VIM_EDITOR}
        return 0
    fi

    eval ${VIM_EDITOR_TAB} "$@"
}

# TODO as var alias
gcd () {
    # cd to git root
    cd "$(git rev-parse --show-toplevel)"
}

git_status_files () {
    # git status file list
    git status --porcelain | awk '{print $2 }'
}

# TODO as var alias
git_parent_branch () {
    # show which branch the current one is forked from
    local current_branch=`git rev-parse --abbrev-ref HEAD`
    git show-branch -a | ack '\*' | ack -v "$current_branch" | head -n1 | sed 's/.*\[\(.*\)\].*/\1/' | sed 's/[\^~].*//'
}

git_tree () {
    # list git tree
    (git ls-tree -r --name-only HEAD || find . -path "*/\.*" -prune -o -type f -print -o -type l -print | sed s/^..//) 2> /dev/null
}

# git push -u origin {BRANCH_NAME}
git_push_branch () {
    git push -u origin "$(git branch --no-color | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')"
}

# show the git log as json
git_log_json () {
    git log --pretty=format:'{%n  "commit": "%H",%n  "abbreviated_commit": "%h",%n  "tree": "%T",%n  "abbreviated_tree": "%t",%n  "parent": "%P",%n  "abbreviated_parent": "%p",%n  "refs": "%D",%n  "encoding": "%e",%n  "subject": "%s",%n  "sanitized_subject_line": "%f",%n  "body": "%b",%n  "commit_notes": "%N",%n  "verification_flag": "%G?",%n  "signer": "%GS",%n  "signer_key": "%GK",%n  "author": {%n    "name": "%aN",%n    "email": "%aE",%n    "date": "%aD"%n  },%n  "commiter": {%n    "name": "%cN",%n    "email": "%cE",%n    "date": "%cD"%n  }%n},'
}
function man () {
# colored man pages
    env \
        LESS_TERMCAP_mb=$(printf "\e[1;31m") \
        LESS_TERMCAP_md=$(printf "\e[1;31m") \
        LESS_TERMCAP_me=$(printf "\e[0m") \
        LESS_TERMCAP_se=$(printf "\e[0m") \
        LESS_TERMCAP_so=$(printf "\e[1;44;33m") \
        LESS_TERMCAP_ue=$(printf "\e[0m") \
        LESS_TERMCAP_us=$(printf "\e[1;32m") \
        man "$@"
}


diff_sorted () {
    diff <(sort "$1") <(sort "$2")
}

# TODO shebang
# TODO mkorg, mkgpg
mk_script () {
    # create an executable script
    touch "$1"
    chmod +x "$1"
    eval ${EDITOR} "$1"
}

mkcd () {
    mkdir $1 && cd $_
}

trash () {
    # move file/dir to trash
    mv "$@" "~/.Trash/."
}

bu () {
    # backup the current directory at the parent directoy
    # use encryption with -e
    dname=$(basename $(pwd))
    cd ..
    if [[ "$1" == "-e" ]]; then
        buname=$dname""_$(date +%d%m%y-%H-%M-%S).tar.gz.enc
        tar cz "$dname/" | openssl enc -aes-256-cbc -e > "$buname"
    else
        buname=$dname""_$(date +%d%m%y-%H-%M-%S).tar.gz
        tar czf "$buname" "$dname/"
    fi
    echo "-> ../$buname"
    cd -  >/dev/null 2>&1
}

# lookup dict.cc
de () {
    # translate de -> en
    dict.cc.py de en "$1"
}
# lookup dict.cc for english words
en () {
    # translate en -> de
    dict.cc.py en de "$1"
}

cp_pwd () {
    # copy the current working dir to clipboard
    pwd | pbcopy
}

= () {
    # calculator
    calc="${@//p/+}"
    calc="${calc//x/*}"
    echo "$(($calc))"
}

clock () {
    # show clock
    while sleep 1;
    do
        tput sc
        tput cup 0 $(($(tput cols)-29))
        date;tput rc
    done &
}

explain () {
    # explain tools
    # https://www.mankier.com/blog/explaining-shell-commands-in-the-shell.html
    if [ "$#" -eq 0 ]; then
        while read  -p "Command: " cmd; do
            curl -Gs "https://www.mankier.com/api/explain/?cols="$(tput cols) --data-urlencode "q=$cmd"
        done
        echo "Bye!"
    elif [ "$#" -eq 1 ]; then
        curl -Gs "https://www.mankier.com/api/explain/?cols="$(tput cols) --data-urlencode "q=$1"
    else
        echo "Usage"
        echo "explain                  interactive mode."
        echo "explain 'cmd -o | ...'   one quoted command to explain it."
    fi
}

    alarm () {
        echo "alarm in ""$1""m"

        local secs=$(($1 * 60))
        # display a timer
        while [ $secs -gt 0 ]; do
            # TODO: format minutes
            echo -ne "$secs\033[0K\r"
            sleep 1
            : $((secs--))
        done

        if [[ "$#" > 1 ]]
        then
            say "$2"
        else
            say "alarm, alarm, alarm"
        fi

        # display a notification
        local title="Alarm"
        local subtitle="$1 minutes since"
        local notification="$(date +%d.%m.%Y-%H:%M:%S)"
        local soundname="Hero"

        # TODO make function
        osascript -e "display notification \"$notification\" with title \"$title\" subtitle \"$subtitle\" sound name \"$soundname\""
    }

    eject () {
        # eject all mountable volumes
        osascript -e 'tell application "Finder" to eject (every disk whose ejectable is true)'
    }

    cdf () {
        # change working directory to Finder path
        cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')"
    }

    toggle_hidden () {
        # toggle show/hide hidden files in finder
        local isVisible=$(defaults read com.apple.finder AppleShowAllFiles)

        # toggle visibility based on variables value
        if [ ${isVisible} = FALSE ]
        then
            defaults write com.apple.finder AppleShowAllFiles TRUE
        else
            defaults write com.apple.finder AppleShowAllFiles FALSE
        fi

        # force changes by restarting Finder
        killall Finder
    }

    zipf () {
        # create a ZIP archive of a file or folder
        zip -r "$1".zip "$1"
    }

    # TODO target
    extract () {
        # extract an archive
        if [ -f $1 ] ; then
            case $1 in
                ,*.tar.bz2)  tar xjf $1      ;;
                ,*.tar.gz)   tar xzf $1      ;;
                ,*.bz2)      bunzip2 $1      ;;
                ,*.rar)      rar x $1        ;;
                ,*.gz)       gunzip $1       ;;
                ,*.tar)      tar xf $1       ;;
                ,*.tbz2)     tar xjf $1      ;;
                ,*.tgz)      tar xzf $1      ;;
                ,*.zip)      unzip $1        ;;
                ,*.Z)        uncompress $1   ;;
                ,*)          echo "'$1' cannot be extracted via extract()" ;;
            esac
        else
            echo "'$1' is not a valid file"
        fi
    }

    # network {
    serve () {
        # serve pwd
        print_ip | awk '{print $1":8000"}'
        # TODO check version
        # python 2
        # python -m SimpleHTTPServer
        python3 -m http.server
    }

    serve_bash () {
        # serve pwd
        print_ip | awk '{print $1":8080"}'
        while true; do { echo -e 'HTTP/1.1 200 OK\r\n'; \
            cat "$1"; } | nc -l 8080; done
    }


    ls_spectrum () {
        # show all 256 colors with color number
        typeset -Ag FX FG BG

        local FX=(
            reset     "%{[00m%}"
            bold      "%{[01m%}" no-bold      "%{[22m%}"
            italic    "%{[03m%}" no-italic    "%{[23m%}"
            underline "%{[04m%}" no-underline "%{[24m%}"
            blink     "%{[05m%}" no-blink     "%{[25m%}"
            reverse   "%{[07m%}" no-reverse   "%{[27m%}"
        )

        for color in {000..255}; do
            FG[$color]="%{[38;5;${color}m%}"
            BG[$color]="%{[48;5;${color}m%}"
        done

        local ZSH_SPECTRUM_TEXT=${ZSH_SPECTRUM_TEXT:-Arma virumque cano Troiae qui primus ab oris}

        for code in {000..255}; do
            print -P -- "$code: %F{$code}$ZSH_SPECTRUM_TEXT%f"
        done
    }

    ls_spectrum_bg () {
        # show all 256 colors where the background is set to specific color
        typeset -Ag FX FG BG

        local FX=(
            reset     "%{[00m%}"
            bold      "%{[01m%}" no-bold      "%{[22m%}"
            italic    "%{[03m%}" no-italic    "%{[23m%}"
            underline "%{[04m%}" no-underline "%{[24m%}"
            blink     "%{[05m%}" no-blink     "%{[25m%}"
            reverse   "%{[07m%}" no-reverse   "%{[27m%}"
        )

        for color in {000..255}; do
            FG[$color]="%{[38;5;${color}m%}"
            BG[$color]="%{[48;5;${color}m%}"
        done

        local ZSH_SPECTRUM_TEXT=${ZSH_SPECTRUM_TEXT:-Arma virumque cano Troiae qui primus ab oris}
        for code in {000..255}; do
            print -P -- "$BG[$code]$code: $ZSH_SPECTRUM_TEXT %{$reset_color%}"
        done
    }

    nyan () {
        # miau miau miau miau miau
        telnet nyancat.dakko.us
    }

    tron () {
        # wasd movement
        ssh sshtron.zachlatta.com
    }
#+END_SRC



* Keybindings
:PROPERTIES:
:CUSTOM_ID: keybindings
:END:
http://zsh.sourceforge.net/Doc/Release/Zsh-Line-Editor.html

to find out what the terminal emulator sends:
$ cat<RET><key-chard>
or
sed -n l<RET>

if this isn't usable let the terminal emulator send escape codes

look up what key corresponds to a given sequence
$ infocmp -L1 | grep -F '=\E[Z'

Scrolling is done via cmd-up/down
** rebindings
https://stackoverflow.com/questions/21946281/what-is-application-mode-in-terminals-zsh-terminfo
#+BEGIN_SRC shell
# Make sure that the terminal is in application mode when zle is active, since
# only then values from $terminfo are valid
if (( ${+terminfo[smkx]} )) && (( ${+terminfo[rmkx]} )); then
    function zle-line-init() {
        echoti smkx
    }
    function zle-line-finish() {
        echoti rmkx
    }
    zle -N zle-line-init
    zle -N zle-line-finish
fi
#+END_SRC

| keychord        | widget                        | description                    |
|-----------------+-------------------------------+--------------------------------|
| Alt-Left        | backward-word                 |                                |
| Alt-Right       | forward-word                  |                                |
| Cmd-Left        | beginning-of-line             |                                |
| Cmd-Right       | end-of-line                   |                                |
| Ctrl-N          | vi-find-next-char             |                                |
| Ctrl-Shift-Left | copy-prev-word                | clone previous word            |
| Cmd-Backspace   | backward-kill-word            |                                |
| Ctrl-X          | delete-char                   |                                |
| Ctrl-K          | cd ..                         |                                |
| Ctrl-L          | ls -lah                       |                                |
| Ctrl-S          | accept-and-hold               | multiselect in menu completion |
| Shift-Tab       | reverse-menu-complete         |                                |
| Up              | history-substring-search-up   |                                |
| Down            | history-substring-search-down |                                |
| Alt-Down        | set-mark-command              |                                |
| Alt-Up          | deactivate-region             |                                |
|-----------------+-------------------------------+--------------------------------|

#+BEGIN_SRC shell
# TODO use terminfo
## movement http://zsh.sourceforge.net/Doc/Release/Zsh-Line-Editor.html#Movement
bindkey '^[^[[D' backward-word                      # alt <arrow-left>............move a word backward
bindkey '^[^[[C' forward-word                       # alt <arrow-right>...........move a word forward
bindkey '^A' beginning-of-line                      # cmd <arrow-left>............move to the beginning of the line
bindkey '^E' end-of-line                            # cmd <arrow-right>...........move to the end of the line
# bindkey '^[[1;2B' down-line
# bindkey '^[[1;2A' up-line
bindkey '^N' vi-find-next-char

## Modifying-Text http://zsh.sourceforge.net/Doc/Release/Zsh-Line-Editor.html#Modifying-Text
bindkey '^[[1;6D' copy-prev-word # ctr shift <-

## kill
bindkey '^[^H' backward-kill-word                   # cmd <del>...................delete the word left of the cursor
bindkey '^X' delete-char                            # ctrl x......................delete the char under the cursor
bindkey '^[k' kill-region
bindkey '^?' backward-delete-char                     # [Backspace] - delete backward
if [[ "${terminfo[kdch1]}" != "" ]]; then
    bindkey "${terminfo[kdch1]}" delete-char            # [Delete] - delete forward
else
    # fixes outputting tildes on <del>
    bindkey "^[[3~" delete-char
    bindkey "^[3;5~" delete-char
    bindkey "\e[3~" delete-char
fi

# eval
bindkey -s '^L' 'ls -laH\n'
bindkey -s '^K' 'cd ..\n'

# menu select
bindkey '^[cks' accept-and-hold
if [[ "${terminfo[kcbt]}" != "" ]]; then
    bindkey "${terminfo[kcbt]}" reverse-menu-complete   # [Shift-Tab] - move through the completion menu backwards
fi

## history
bindkey "$terminfo[kcuu1]" history-substring-search-up
bindkey "$terminfo[kcud1]" history-substring-search-down

## mark / region
bindkey '^[^[[B' set-mark-command
bindkey '^[^[[A' deactivate-region
#+END_SRC


** custom zle widgets
https://superuser.com/questions/691925/zsh-how-to-zle-widgets-directly
*** repeat last command
#+BEGIN_SRC shell
function repeat-cmd () {
    # repeat the last command
    zle up-history
    zle accept-line
}

zle -N repeat-cmd
# ctrl l
bindkey '^H' repeat-cmd
#+END_SRC

*** wrap in $()
#+BEGIN_SRC shell
function wrap-call () {
    # wrap the cursor in "$()"
    LBUFFER+="\"\$("
    RBUFFER+=")\""
}

zle -N wrap-call
# esc (
bindkey '^[(' wrap-call
#+END_SRC

*** wrap in ${}
#+BEGIN_SRC shell
function wrap-var () {
    # wrap the cursor in "${}"
    LBUFFER+="\"\${"
    RBUFFER+="}\""
}

zle -N wrap-var
# esc {
bindkey '^[{' wrap-var
#+END_SRC

*** kill first word
#+BEGIN_SRC shell
function kill-first-word () {
    # kill the first word on the cmdline and move cursor to beginning of line
    zle beginning-of-line
    zle forward-word
    zle backward-kill-word
    LBUFFER+=' '
    zle backward-word
}

zle -N kill-first-word
# ctrl shift f
bindkey '^[cskf' kill-first-word
#+END_SRC

*** kill word under cursor
#+BEGIN_SRC shell
function kill-word-under-cursor () {
    # kill the word under the cursor
    zle forward-word
    zle backward-kill-word
}

zle -N kill-word-under-cursor
# ctrl shift w
bindkey '^[cskw' kill-word-under-cursor
#+END_SRC

*** cp cmdline
#+BEGIN_SRC shell
function copy-cmdline-to-clipboard () {
    # Copy the current commandline to the system clipboard
    zle kill-whole-line
    print -rn -- $CUTBUFFER | pbcopy
    zle undo
}

zle -N copy-cmdline-to-clipboard
# esc c
bindkey '^[c' copy-cmdline-to-clipboard
#+END_SRC

**** rationalise dot
#+BEGIN_SRC shell
function rationalise-dot() {
    # expands .... to ../../..
    if [[ $LBUFFER = *.. ]]; then
        LBUFFER+=/..
    else
        LBUFFER+=.
    fi
}
zle -N rationalise-dot
bindkey . rationalise-dot
#+END_SRC

**** path step
#+BEGIN_SRC shell
function backward-delete-path-part () {
    # backward delete until /
    # TODO document
    # local WORDCHARS="${WORDCHARS:s#/#}"
    local WORDCHARS="${WORDCHARS//\/}"
    zle backward-delete-word
}
zle -N backward-delete-path-part
bindkey '^W' backward-delete-path-part
#+END_SRC

* Plugins
:PROPERTIES:
:CUSTOM_ID: plugins
:END:
** zsh-autosuggestions
#+BEGIN_SRC shell
source ~dotfiles/zsh/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh
#+END_SRC

** zsh-history-search-multi-word
https://github.com/zdharma/history-search-multi-word
#+BEGIN_SRC shell
# source ~dotfiles/zsh/plugins/history-search-multi-word/history-search-multi-word.plugin.zsh
#+END_SRC

** zsh-history-substring-search                                     :plugin:
https://github.com/zsh-users/zsh-history-substring-search
#+BEGIN_SRC shell
source ~dotfiles/zsh/plugins/zsh-history-substring-search/zsh-history-substring-search.zsh
#+END_SRC

** fast-syntax-highlighting                                                           :plugin:
https://github.com/zdharma/fast-syntax-highlighting
#+BEGIN_SRC shell
source ~dotfiles/zsh/plugins/fast-syntax-highlighting/fast-syntax-highlighting.plugin.zsh
#+END_SRC

** k                                                                :plugin:
TODO LS_COLORS
https://github.com/supercrabtree/k
#+BEGIN_SRC shell
source ~dotfiles/zsh/plugins/k/k.sh
#+END_SRC

** fzf                                                            :plugin:
https://github.com/junegunn/fzf
https://github.com/junegunn/fzf/wiki

# TODO complete; move to bindings
| shortcut      | action                                                        |
|---------------+---------------------------------------------------------------|
| CTRL-R        | Paste the selected command from history into the command line |
| CTRL-F        | Paste the selected file path(s) into the command line         |
| CTRL-G        | Paste the selected dir path(s) into the command line          |
| CTRL-G CTRL-G | cd into the selected directory                                |
| CTRL-G CTRL-F | git files                                                     |
| CTRL-G CTRL-B | git branches                                                  |
| CTRL-G CTRL-T | git tags                                                      |
| CTRL-G CTRL-R | git remotes                                                   |
| CTRL-G CTRL-H | git commit hashes                                             |

# TODO source out
Solarized colors
  --color=bg+:#073642,bg:#002b36,spinner:#719e07,hl:#586e75
  --color=fg:#839496,header:#586e75,info:#cb4b16,pointer:#719e07
  --color=marker:#719e07,fg+:#839496,prompt:#719e07,hl+:#719e07

Red
--color fg:124,bg:16,hl:202,fg+:214,bg+:52,hl+:231
--color info:52,prompt:196,spinner:208,pointer:196,marker:208

Molokai
--color fg:252,bg:233,hl:67,fg+:252,bg+:235,hl+:81
--color info:144,prompt:161,spinner:135,pointer:135,marker:118

Jellybeans
--color fg:188,bg:233,hl:103,fg+:222,bg+:234,hl+:104
--color info:183,prompt:110,spinner:107,pointer:167,marker:215

JellyX
--color fg:-1,bg:-1,hl:230,fg+:3,bg+:233,hl+:229
--color info:150,prompt:110,spinner:150,pointer:167,marker:174

Seoul256 Dusk
--color fg:242,bg:236,hl:65,fg+:15,bg+:239,hl+:108
--color info:108,prompt:109,spinner:108,pointer:168,marker:168

Seoul256 Night
--color fg:242,bg:233,hl:65,fg+:15,bg+:234,hl+:108
--color info:108,prompt:109,spinner:108,pointer:168,marker:168

Solarized Dark
--color dark,hl:33,hl+:37,fg+:235,bg+:136,fg+:254
--color info:254,prompt:37,spinner:108,pointer:235,marker:235

Solarized Light
--color fg:240,bg:230,hl:33,fg+:241,bg+:221,hl+:33
--color info:33,prompt:33,pointer:166,marker:166,spinner:33

Alternate Solarized Light/Dark Theme
export base03="234"
export base02="235"
export base01="240"
export base00="241"
export base0="244"
export base1="245"
export base2="254"
export base3="230"
export yellow="136"
export orange="166"
export red="160"
export magenta="125"
export violet="61"
export blue="33"
export cyan="37"
export green="64"
 --color fg:-1,bg:-1,hl:$blue,fg+:$base2,bg+:$base02,hl+:$blue
 --color info:$yellow,prompt:$yellow,pointer:$base3,marker:$base3,spinner:$yellow

--color fg:-1,bg:-1,hl:$blue,fg+:$base02,bg+:$base2,hl+:$blue
--color info:$yellow,prompt:$yellow,pointer:$base03,marker:$base03,spinner:$yellow

# TODO keybindings as functions
#+BEGIN_SRC shell
## source completions and bindings
source ~dotfiles/zsh/plugins/fzf/completion.zsh
# https://junegunn.kr/2016/07/fzf-git/
source ~dotfiles/zsh/plugins/fzf/git-completion.zsh
source ~dotfiles/zsh/plugins/fzf/key-bindings.zsh
# TODO steal, fullscreen
source ~dotfiles/zsh/plugins/forgit/forgit.plugin.zsh

## default commands
export FZF_DEFAULT_COMMAND="
    (git ls-tree -r --name-only HEAD \$(git rev-parse --show-toplevel) ||
    rg --files --no-ignore --hidden --follow -g '!{.git,node_modules}/*') 2> /dev/null"

# TODO preview with someting fast, fallback to pygmentize
export FZF_DEFAULT_OPTS="--multi --cycle --select-1 --exit-0
    --border --margin 1% --prompt 'ϟ ' --no-height --no-reverse
    --color fg:-1,bg:-1,hl:230,fg+:3,bg+:233,hl+:229
    --color info:150,prompt:110,spinner:150,pointer:167,marker:174
    --header='(^start) | (end\$) | (’exact) | (!not) | OR (^core go\$ | rb\$ | py\$)'
    --preview-window right:40%
    --preview '[[ -d {} ]] && tree -C {} | head -200 ||
               [[ \$(file --mime-type -b {}) =~ image ]] && ls -lah {} && imgcat --256 -w 80 {} 2> /dev/null ||
                 (ls -lah {} &&
                  pygmentize {} ||
                  cat {}) 2> /dev/null | head -500'
    --bind 'ctrl-e:execute(\$EDITOR {})+accept'
    --bind 'ctrl-o:execute(open {})+accept'
    --bind 'ctrl-y:execute(echo {}|pbcopy)+accept'
    --bind 'ctrl-j:jump'"

# to apply the command to CTRL-T as well (CTRL-F in my case)
export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
# TODO get cp working
# export FZF_CTRL_T_OPTS="--bind 'ctrl-x:execute(echo {}|awk '{print \$2}'|pbcopy)+accept'"
#+END_SRC

* Theme
** TODO fzf
** TODO from vim
** TODO basecolor16
#+BEGIN_SRC shell
export PROMPT='%F{green}%n%f@%F{blue}%m%f %F{red}%~ %f% %# '
#+END_SRC

* Original zshrc
:PROPERTIES:
:CUSTOM_ID: original-zshrc
:END:

#+BEGIN_SRC shell :tangle no
  # zsh configs {{{
      # init completion
      autoload -U compinit && compinit
      # enable vcs_info used by the prompt
      autoload -Uz vcs_info
      zstyle ':vcs_info:*' enable git svn
      precmd() { vcs_info }

      # completion {
          # enable vcs_info used by the prompt
          autoload -U compinit && compinit
    
          zstyle ':completion:*' completer _expand _complete
    
          # allow approximate matching
          zstyle ':completion:*' completer _complete _match _approximate
          zstyle ':completion:*:match:*' original only
          # init completion
          autoload -U compinit && compinit
      # #}



      # ls --color
      # LS_COLORS='di=36:ln=35:so=32:pi=33:ex=31:bd=34;46:cd=34;43:su=30;41:sg=30;46:tw=30;42:ow=30;43'
      # LSCOLORS='gxfxcxdxbxegedabagacad'

      # gnu dircolors
      alias dircolors='gdircolors'
      eval `dircolors /Users/mbayer/Settings/dotfiles/zenburn.256dark`
  # }}}

  # antigen {{{
      # source $HOME/.oh-my-zsh/custom/plugins/antigen/antigen.zsh
      #
      # # load the oh-my-zsh's library.
      # antigen use oh-my-zsh
      #
      # # bundles from the default repo (robbyrussell's oh-my-zsh).
      # antigen bundle osx
      # antigen bundle brew
      # antigen bundle git
      # antigen bundle python
      # antigen bundle pip
      # antigen bundle docker
      # antigen bundle jsontools
      # antigen bundle urltools
      # antigen bundle web-search
      #
      # # additional bundles
      # antigen bundle zsh-users/zsh-syntax-highlighting
      # antigen bundle zsh-users/zsh-autosuggestions
      # antigen bundle zsh-users/zsh-completions
      # antigen bundle zsh-users/zsh-history-substring-search
      #
      # antigen bundle jocelynmallon/zshmarks
      #
      # # Tell antigen that you're done.
      # antigen apply
  # }}}

  # oh-my-zsh configs {{{

      ZSH=$HOME/.oh-my-zsh

      ZSH_THEME="impure"
      # ZSH_THEME="bay"
      # ZSH_THEME="random"
      CASE_SENSITIVE="false"
      COMPLETION_WAITING_DOTS="false"

      plugins=(
          osx
          brew
          python
          pip
          zshmarks
          pure
          docker
          jsontools
          urltools
          web-search
          zsh-completions
          zsh-syntax-highlighting
          zsh-history-substring-search
          k
          ztrace
          impure)

      source $ZSH/oh-my-zsh.sh
  # }}}

  # plugins-settings {{{
      # fortune ponies {
          fortune | ponysay
      # }

      # fzf {
          source ~/.oh-my-zsh/custom/plugins/fzf/completion.zsh

                  # ag -g "" --path-to-agignore ~/.agignore'
# Feed the output of ag into fzf
alias fzf_ag='ag -g "" | fzf'
          # }
      # }
  # }}}

  # python {{{
      # }
  # }}}

  # docker {{{
      export OSX_PRIVATE=/private
      # $(boot2docker shellinit 2> /dev/null)
      # export DOCKER_HOST=tcp://192.168.59.103:2376
      # export DOCKER_CERT_PATH=$HOME/.boot2docker/certs/boot2docker-vm
      # export DOCKER_TLS_VERIFY=1
  # }}}


  # keybindings / keymappings {{{
      # vi mode
      # bindkey -v

      # TODO: remove
      # bind UP and DOWN arrow keys to history-substring-search
      # zmodload zsh/terminfo
      # bindkey "$terminfo[kcuu1]" history-substring-search-up
      # bindkey "$terminfo[kcud1]" history-substring-search-down

      # widgets
      # _last_command_args() {
      #     last_command=$history[$[HISTCMD-1]]
      #     last_command_array=("${(s/ /)last_command}") 
      #     _sep_parts last_command_array
      # }
      # zstyle ':completion:*' completer _last_command_args _complete


          # tab completion for git status files {
              if [[ $- == *i* ]]; then

                  # CTRL-h - Paste the selected hash(s) into the command line
                  # hash -d | grep -v '_'|awk -F = '{print "~"$1"/""\t\t"$2}'

                  # CTRL-f - Paste the selected file path(s) into the command line
                  __fsel() {
                    local cmd="${FZF_CTRL_T_COMMAND:-"command find -L . \\( -path '*/\\.*' -o -fstype 'dev' -o -fstype 'proc' \\) -prune \
                      -o -type f -print \
                      -o -type d -print \
                      -o -type l -print 2> /dev/null | sed 1d | cut -b3-"}"
                    eval "$cmd" | $(__fzfcmd) -m | while read item; do
                      printf '%q ' "$item"
                    done
                    echo
                  }

                  # CTRL-p - Paste the selected directory path(s) into the command line
                  __fsel-dir() {
                    local cmd="${FZF_ALT_C_COMMAND:-"command find -L . \\( -path '*/\\.*' -o -fstype 'dev' -o -fstype 'proc' \\) -prune \
                      -o -type d -print 2> /dev/null | sed 1d | cut -b3-"}"
                    eval "$cmd" | $(__fzfcmd) -m | while read item; do
                      printf '%q ' "$item"
                    done
                    echo
                  }

                  __fzfcmd() {
                    [ ${FZF_TMUX:-1} -eq 1 ] && echo "fzf-tmux -d${FZF_TMUX_HEIGHT:-40%}" || echo "fzf"
                  }

                  fzf-file-widget() {
                    LBUFFER="${LBUFFER}$(__fsel)"
                    zle redisplay
                  }
                  zle     -N   fzf-file-widget
                  bindkey '^F' fzf-file-widget

                  fzf-dir-widget() {
                    LBUFFER="${LBUFFER}$(__fsel-dir)"
                    zle redisplay
                  }
                  zle     -N   fzf-dir-widget
                  bindkey '^P' fzf-dir-widget

                  # Ctrl-g - cd into the selected directory
                  fzf-cd-widget() {
                    local cmd="${FZF_ALT_C_COMMAND:-"command find -L . \\( -path '*/\\.*' -o -fstype 'dev' -o -fstype 'proc' \\) -prune \
                      -o -type d -print 2> /dev/null | sed 1d | cut -b3-"}"
                    cd "${$(eval "$cmd" | $(__fzfcmd) +m):-.}" && pwd
                    zle reset-prompt
                  }
                  zle     -N    fzf-cd-widget
                  bindkey '^G' fzf-cd-widget

                  # CTRL-r - Paste the selected command from history into the command line
                  fzf-history-widget() {
                    local selected num
                    selected=( $(fc -l 1 | $(__fzfcmd) +s --tac +m -n2..,.. --tiebreak=index --toggle-sort=ctrl-r -q "${LBUFFER//$/\\$}") )
                    if [ -n "$selected" ]; then
                      num=$selected[1]
                      if [ -n "$num" ]; then
                        zle vi-fetch-history -n $num
                      fi
                    fi
                    zle redisplay
                  }
                  zle     -N   fzf-history-widget
                  bindkey '^R' fzf-history-widget
              fi
          # }

          # magic enter = ls && git status {
              do_enter () {
                  if [ -n "$BUFFER" ]; then
                      zle accept-line
                      return 0
                  fi
                  echo
                  ls
                  if [ "$(git rev-parse --is-inside-work-tree 2> /dev/null)" = 'true' ]; then
                      echo
                      echo -e "\e[0;33m--- git status ---\e[0m"
                      git status -sb
                  fi
                  zle reset-prompt
                  return 0
              }
              zle -N do_enter
              bindkey '^m' do_enter
          # }

          # rational dots {
              # type '...' to get '../..' with successive .'s adding /..
              function rationalise_dot {
                  local MATCH # keep the regex match from leaking to the environment
                  if [[ $LBUFFER =~ '(^|/| |      |'$'\n''|\||;|&)\.\.$' ]]; then
                    LBUFFER+=/
                    zle self-insert
                    zle self-insert
                  else
                    zle self-insert
                  fi
              }
              zle -N rationalise_dot
              bindkey . rationalise_dot
              # without this, typing a . aborts incremental history search
              bindkey -M isearch . self-insert
          # }
      # }

      bindkey -e
      export WORDCHARS=''                                 # do not jump over whole POSIX path
      bindkey '^N' accept-and-hold                        # ctrl n .................... multiselect in menu complete
      bindkey '^[^[[D' backward-word                      # alt <arrow-left>............move a word backward
      bindkey '^[^[[C' forward-word                       # alt <arrow-right>...........move a word forward
      bindkey '^[^H' backward-kill-word                   # cmd <del>...................delete the word left of the cursor
      bindkey '^A' beginning-of-line                      # cmd <arrow-left>............move to the beginning of the line
      bindkey '^E' end-of-line                            # cmd <arrow-right>...........move to the end of the line
      bindkey '^[^[[B' kill-whole-line                    # cmd <arrow-down>............delete the whole line
      bindkey '^X' delete-char                            # ctrl x......................delete the char under the cursor
      bindkey '^W' delete-word                            # ctrl w......................delete the word under the cursor
      bindkey -s '^[^[[A' 'cd ..\n'                       # alt <arrow-up>..............cd ..
      bindkey -s '^L' 'ls -laH\n'                         # ctr l.......................ls -laH
      bindkey '^[[A' history-beginning-search-backward    # <arrow-up>..................history substring search backward
      bindkey '^[[B' history-beginning-search-forward     # <arrow-down>................history substring search forward
  # }}}



  test -e "${HOME}/.iterm2_shell_integration.zsh" && source "${HOME}/.iterm2_shell_integration.zsh"


cdf () {  # short for cdfinder
  cd "`osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)'`"
}
# Copy w/ progress
cp_p () {
  rsync -WavP --human-readable --progress $1 $2
}

# who is using the laptop's iSight camera?
camerausedby () {
  echo "Checking to see who is using the iSight camera… 📷"
  usedby=$(lsof | grep -w "AppleCamera\|USBVDC\|iSight" | awk '{printf $2"\n"}' | xargs ps)
  echo -e "Recent camera uses:\n$usedby"
}

# animated gifs from any video
# from Alex Sexton gist.github.com/SlexAxton/4989674
gifify () {
  if [[ -n "$1" ]]; then
  if [[ $2 == '--good' ]]; then
    ffmpeg -i "$1" -r 10 -vcodec png out-static-%05d.png
    time convert -verbose +dither -layers Optimize -resize 900x900\> out-static*.png  GIF:- | gifsicle --colors 128 --delay=5 --loop --optimize=3 --multifile - > "$1.gif"
    rm out-static*.png
  else
    ffmpeg -i "$1" -s 600x400 -pix_fmt rgb24 -r 10 -f gif - | gifsicle --optimize=3 --delay=3 > "$1.gif"
  fi
  else
  echo "proper usage: gifify <input_movie.mov>. You DO need to include extension."
  fi
}

# turn that video into webm.
# brew reinstall ffmpeg --with-libvpx
webmify () {
  ffmpeg -i "$1" -vcodec libvpx -acodec libvorbis -isync -copyts -aq 80 -threads 3 -qmax 30 -y "$2" "$1.webm"
}
# Get week number
alias week='date +%V'

# Get macOS Software Updates, and update installed Ruby gems, Homebrew, npm, and their installed packages
alias update='sudo softwareupdate -i -a; brew update; brew upgrade; brew cleanup; npm install npm -g; npm update -g; sudo gem update --system; sudo gem update; sudo gem cleanup'

alias ip="dig +short myip.opendns.com @resolver1.opendns.com"
alias localip="ipconfig getifaddr en0"
alias ips="ifconfig -a | grep -o 'inet6\? \(addr:\)\?\s\?\(\(\([0-9]\+\.\)\{3\}[0-9]\+\)\|[a-fA-F0-9:]\+\)' | awk '{ sub(/inet6? (addr:)? ?/, \"\"); print }'"

# JavaScriptCore REPL

jscbin="/System/Library/Frameworks/JavaScriptCore.framework/Versions/A/Resources/jsc";
[ -e "${jscbin}" ] && alias jsc="${jscbin}";
unset jscbin;

# Trim new lines and copy to clipboard
alias c="tr -d '\n' | pbcopy"

# Hide/show all desktop icons (useful when presenting)
alias hidedesktop="defaults write com.apple.finder CreateDesktop -bool false && killall Finder"
alias showdesktop="defaults write com.apple.finder CreateDesktop -bool true && killall Finder"


# URL-encode strings
alias urlencode='python -c "import sys, urllib as ul; print ul.quote_plus(sys.argv[1]);"'
# Merge PDF files
# Usage: `mergepdf -o output.pdf input{1,2,3}.pdf`
alias mergepdf='/System/Library/Automator/Combine\ PDF\ Pages.action/Contents/Resources/join.py'

# Intuitive map function
# For example, to list all directories that contain a certain file:
# find . -name .gitattributes | map dirname
alias map="xargs -n1"

# One of @janmoesen’s ProTip™s
for method in GET HEAD POST PUT DELETE TRACE OPTIONS; do
	alias "${method}"="lwp-request -m '${method}'"
done

# Stuff I never really use but cannot delete either because of http://xkcd.com/530/
alias stfu="osascript -e 'set volume output muted true'"
alias pumpitup="osascript -e 'set volume output volume 100'"

# Lock the screen (when going AFK)
alias afk="/System/Library/CoreServices/Menu\ Extras/User.menu/Contents/Resources/CGSession -suspend"

# Reload the shell (i.e. invoke as a login shell)
alias reload="exec ${SHELL} -l"

# Print each PATH entry on a separate line
alias path='echo -e ${PATH//:/\\n}'

# Syntax-highlight JSON strings or files
# Usage: `json '{"foo":42}'` or `echo '{"foo":42}' | json`
function json() {
	if [ -t 0 ]; then # argument
		python -mjson.tool <<< "$*" | pygmentize -l javascript;
	else # pipe
		python -mjson.tool | pygmentize -l javascript;
	fi;
}

  eg(){
  # https://news.ycombinator.com/item?id=10797303
      MAN_KEEP_FORMATTING=1 man "$@" 2>/dev/null \
          | sed --quiet --expression='/^E\(\x08.\)X\(\x08.\)\?A\(\x08.\)\?M\(\x08.\)\?P\(\x08.\)\?L\(\x08.\)\?E/{:a;p;n;/^[^ ]/q;ba}' \
          | ${MANPAGER:-${PAGER:-pager -s}}
  }

#+END_SRC
